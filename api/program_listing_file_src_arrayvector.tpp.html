

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File arrayvector.tpp &mdash; brille  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        <script src="../_static/katex_autorenderer.js"></script>
        <script src="../_static/collapsible-lists\js\CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists\js\apply-collapsible-lists.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/katex-math.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists\css\tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> brille
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User documents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install_guide.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../motivation.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_usage.html">Memory Use</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">User Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">API documents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../brille.html">Python module <code class="docutils literal notranslate"><span class="pre">brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../brille.html#pybind11-module-brille">pybind11 module <code class="docutils literal notranslate"><span class="pre">_brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../plotting.html">Plotting utilities for <code class="docutils literal notranslate"><span class="pre">brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">C++ Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">brille</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Program Listing for File arrayvector.tpp</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_src_arrayvector.tpp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-arrayvector-tpp">
<span id="program-listing-file-src-arrayvector-tpp"></span><h1>Program Listing for File arrayvector.tpp<a class="headerlink" href="#program-listing-for-file-arrayvector-tpp" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_src_arrayvector.tpp.html#file-src-arrayvector-tpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src\arrayvector.tpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>/* Copyright 2019 Greg Tucker
//
// This file is part of brille.
//
// brille is free software: you can redistribute it and/or modify it under the
// terms of the GNU Affero General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
//
// brille is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with brille. If not, see &lt;https://www.gnu.org/licenses/&gt;.            */

// Templated implementation code for arrayvector.hpp

template&lt;typename T&gt; T* ArrayVector&lt;T&gt;::checked_data(const size_t i, const size_t j) const {
  T *ptr = nullptr;
  if (i&gt;=this-&gt;size() || j&gt;=this-&gt;numel()){
    std::string msg = __PRETTY_FUNCTION__;
    msg += &quot;\n Attempting to access the pointer to element &quot; +std::to_string(j);
    msg += &quot; of array &quot; + std::to_string(i) + &quot; but the ArrayVector holds &quot;;
    msg += std::to_string(this-&gt;size()) + &quot; arrays each with &quot;;
    msg += std::to_string(this-&gt;numel()) + &quot; elements&quot;;
    throw std::out_of_range(msg);
  }
  ptr = this-&gt;data(i, j);
  if (!ptr){
    throw std::runtime_error(&quot;Attempting to access uninitialized data&quot;);
  }
  return ptr;
}
template&lt;typename T&gt; T* ArrayVector&lt;T&gt;::data(const size_t i, const size_t j) const {
  return this-&gt;_data + (i*this-&gt;numel() + j);
}

template&lt;typename T&gt; T ArrayVector&lt;T&gt;::getvalue(const size_t i, const size_t j) const {
  T *ptr, out;
  ptr = this-&gt;data(i,j);
  out = *ptr;
  return out;
}
template&lt;typename T&gt; ArrayVector&lt;T&gt; ArrayVector&lt;T&gt;::extract(const size_t i) const {
  if (i&lt;this-&gt;size()){
    ArrayVector&lt;T&gt; out(this-&gt;numel(),1u,this-&gt;data(i));
    return out;
  }
  std::string msg = &quot;The requested element &quot; + std::to_string(i);
  msg += &quot; is out of bounds for an ArrayVector with size()= &quot;;
  msg += std::to_string(this-&gt;size());
  throw std::out_of_range(msg);
}
template&lt;typename T&gt; ArrayVector&lt;T&gt; ArrayVector&lt;T&gt;::first(const size_t num) const {
  size_t stop = num &lt; this-&gt;size() ? num : this-&gt;size();
  ArrayVector&lt;T&gt; out(this-&gt;numel(), stop);
  for (size_t j=0; j&lt;stop; j++) out.set(j, this-&gt;data(j) );
  return out;
}
template&lt;typename T&gt; ArrayVector&lt;T&gt; ArrayVector&lt;T&gt;::extract(const size_t n, const size_t *i) const {
  bool allinbounds = true;
  ArrayVector&lt;T&gt; out(this-&gt;numel(),0u);
  for (size_t j=0; j&lt;n; j++) if ( !(i[j]&lt;this-&gt;size()) ){ allinbounds=false; break; }
  if (allinbounds){
    out.resize(n);
    for (size_t j=0; j&lt;n; j++) out.set(j, this-&gt;data(i[j]) );
  }
  return out;
}
template&lt;typename T&gt;
template&lt;typename I, typename&gt;
ArrayVector&lt;T&gt; ArrayVector&lt;T&gt;::extract(const ArrayVector&lt;I&gt;&amp; idx) const {
  bool allinbounds = true;
  ArrayVector&lt;T&gt; out(this-&gt;numel(), 0u);
  if (idx.numel() != 1u &amp;&amp; idx.size() != 1u){
    std::string msg = &quot;copying an ArrayVector by index ArrayVector&lt;Integer&gt;&quot;;
    msg += &quot; requires numel()==1 or size()==1&quot;;
    msg += &quot; and the provided input has (size,numel)=(&quot;;
    msg += std::to_string(idx.size())+&quot;,&quot;+std::to_string(idx.numel())+&quot;)&quot;;
    throw std::runtime_error(msg);
  }
  for (size_t i=0; i&lt;idx.size(); ++i) for (size_t j=0; j&lt;idx.numel(); ++j)
  if (static_cast&lt;size_t&gt;(idx.getvalue(i,j)) &gt;= this-&gt;size() || idx.getvalue(i,j)&lt;0)
    allinbounds = false;
  if (allinbounds){
    if (idx.numel()==1u){
      out.resize(idx.size());
      for (size_t j=0; j&lt;idx.size(); ++j) out.set(j, this-&gt;data( idx.getvalue(j)) );
    } else {
      out.resize(idx.numel());
      for (size_t j=0; j&lt;idx.numel(); ++j) out.set(j, this-&gt;data(idx.getvalue(0,j)));
    }
  }
  return out;
}
template&lt;typename T&gt;
template&lt;typename I, typename&gt; // restricted to integer I
ArrayVector&lt;T&gt; ArrayVector&lt;T&gt;::extract(const std::vector&lt;I&gt;&amp; idx) const {
  ArrayVector&lt;T&gt; out(this-&gt;numel(),0u);
  size_t this_size = this-&gt;size();
  if (!std::all_of(idx.begin(), idx.end(), [this_size](I j){return j&gt;=0 || static_cast&lt;size_t&gt;(j)&lt;this_size;})){
    std::string msg = &quot;Attempting to extract out of bounds ArrayVector(s): [&quot;;
    for (auto i: idx) msg += &quot; &quot; + std::to_string(i);
    msg += &quot; ] but size() = &quot; + std::to_string(this-&gt;size());
    throw std::out_of_range(msg);
  }
  out.resize(idx.size());
  for (size_t j=0; j&lt;idx.size(); ++j) out.set(j, this-&gt;data(idx[j]) );
  return out;
}
template&lt;typename T&gt;
template&lt;typename I, typename, size_t Nel&gt; // restricted to integer I
ArrayVector&lt;T&gt; ArrayVector&lt;T&gt;::extract(const std::array&lt;I, Nel&gt;&amp; idx) const {
  ArrayVector&lt;T&gt; out(this-&gt;numel(),0u);
  size_t this_size = this-&gt;size();
  if (!std::all_of(idx.begin(), idx.end(), [this_size](I j){return j&gt;=0 || static_cast&lt;size_t&gt;(j)&lt;this_size;})){
    std::string msg = &quot;Attempting to extract out of bounds ArrayVector(s): [&quot;;
    for (auto i: idx) msg += &quot; &quot; + std::to_string(i);
    msg += &quot; ] but size() = &quot; + std::to_string(this-&gt;size());
    throw std::out_of_range(msg);
  }
  out.resize(Nel);
  for (size_t j=0; j&lt;Nel; ++j) out.set(j, this-&gt;data(idx[j]) );
  return out;
}
template&lt;typename T&gt; ArrayVector&lt;T&gt; ArrayVector&lt;T&gt;::extract(const ArrayVector&lt;bool&gt;&amp; tf) const{
  if (tf.numel() != 1u || tf.size() != this-&gt;size()){
    std::string msg = &quot;Extracting an ArrayVector by logical indexing requires&quot;;
    msg += &quot; an ArrayVector&lt;bool&gt; with numel()==1&quot;;
    msg += &quot; and size()==ArrayVector.size().&quot;;
    throw std::runtime_error(msg);
  }
  size_t nout=0;
  for (size_t i=0; i&lt;tf.size(); ++i) if (tf.getvalue(i,0)) ++nout;
  ArrayVector&lt;T&gt; out(this-&gt;numel(),nout);
  size_t idx = 0;
  for (size_t i=0; i&lt;tf.size(); ++i)
    if (tf.getvalue(i,0)) out.set(idx++, this-&gt;data(i));
  return out;
}
template&lt;typename T&gt; ArrayVector&lt;T&gt; ArrayVector&lt;T&gt;::extract(const std::vector&lt;bool&gt;&amp; t) const{
  if (t.size() != this-&gt;size()){
    std::string msg = &quot;Extracting an ArrayVector by logical indexing requires&quot;;
    msg += &quot; a std::vector&lt;bool&gt; with size()==ArrayVector.size().&quot;;
    msg += &quot; Instead got &quot; + std::to_string(t.size()) + &quot; where &quot; + std::to_string(this-&gt;size()) + &quot; was expected&quot;;
    throw std::runtime_error(msg);
  }
  ArrayVector&lt;T&gt; o(this-&gt;numel(), std::count(t.begin(), t.end(), true));
  size_t j = 0;
  for (size_t i=0; i&lt;t.size(); ++i) if (t[i]) o.set(j++, this-&gt;data(i));
  return o;
}
template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::get(const size_t i, T* out) const {
  if (i&gt;this-&gt;size()-1) return false;
  for (size_t j=0; j&lt;this-&gt;numel(); j++) out[j]= this-&gt;getvalue(i,j);
  return true;
}
template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::set(const size_t i, const T* in){
  if (i&gt;this-&gt;size()-1) return false;
  for (size_t j=0; j&lt;this-&gt;numel(); j++) this-&gt;_data[i*this-&gt;numel()+j] = in[j];
  return true;
}
template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::set(const size_t i, const ArrayVector&lt;T&gt;* in){
  if (i&gt;this-&gt;size()-1 || this-&gt;numel()!=in-&gt;numel() || in-&gt;size()&lt;1u ) return false;
  for (size_t j=0; j&lt;this-&gt;numel(); j++) this-&gt;insert( in-&gt;getvalue(0,j), i,j) ;
  return true;
}
template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::set(const size_t i, const ArrayVector&lt;T&gt;&amp; in){
  if (i&gt;this-&gt;size()-1 || this-&gt;numel()!=in.numel() || in.size()&lt;1u ) return false;
  for (size_t j=0; j&lt;this-&gt;numel(); j++) this-&gt;insert( in.getvalue(0,j), i,j) ;
  return true;
}
template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::set(const size_t i, const std::vector&lt;T&gt;&amp; in){
  if (i&gt;this-&gt;size()-1 || this-&gt;numel()!=in.size()) return false;
  for (size_t j=0; j&lt;this-&gt;numel(); ++j) this-&gt;insert(in[j], i, j);
  return true;
}
template&lt;typename T&gt;template&lt;size_t Nel&gt; bool ArrayVector&lt;T&gt;::set(const size_t i, const std::array&lt;T,Nel&gt;&amp; in){
  if (i&gt;this-&gt;size()-1 || this-&gt;numel()!=Nel) return false;
  for (size_t j=0; j&lt;this-&gt;numel(); ++j) this-&gt;insert(in[j], i, j);
  return true;
}
template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::insert(const T in, const size_t i, const size_t j){
  bool inrange = i&lt;this-&gt;size() &amp;&amp; j&lt;this-&gt;numel();
  if (inrange) this-&gt;_data[i*this-&gt;numel()+j] = in;
  return inrange;
}
template&lt;typename T&gt; void ArrayVector&lt;T&gt;::printformatted(const char * fmt,const size_t first, const size_t last, const char * after) const {
  size_t i,j,b=this-&gt;numel();
  for (i=first;i&lt;last;i++){ for (j=0;j&lt;b;j++) printf(fmt,this-&gt;getvalue(i,j)); printf(after);  }
}
template&lt;typename T&gt; void ArrayVector&lt;T&gt;::print() const {
  const char * fmt = std::is_floating_point&lt;T&gt;::value ? &quot; % g &quot; : &quot; % d &quot;;
  this-&gt;printformatted(fmt,0,this-&gt;size(),&quot;\n&quot;);
}
template&lt;typename T&gt; void ArrayVector&lt;T&gt;::print(const size_t i) const {
  this-&gt;print(i,i,&quot;\0&quot;);
}
template&lt;typename T&gt; void ArrayVector&lt;T&gt;::print(const size_t first, const size_t last, const char *after) const {
  const char * fmt = std::is_floating_point&lt;T&gt;::value ? &quot; % g &quot; : &quot; % d &quot;;
  if (first&lt;this-&gt;size() &amp;&amp; last&lt;this-&gt;size())
    this-&gt;printformatted(fmt,first,last+1,after);
  else {
    std::string msg = &quot;Attempted to print elements &quot;;
    msg += std::to_string(first) + &quot; to &quot; + std::to_string(last);
    msg += &quot; of size()= &quot; + std::to_string(this-&gt;size()) + &quot; ArrayVector&quot;;
    throw std::out_of_range(msg);
  }
}

template&lt;typename T&gt; void ArrayVector&lt;T&gt;::printheader(const char* name) const {
  std::string header = std::string(name) + &quot; numel &quot;
                     + std::to_string(this-&gt;numel()) + &quot;, size &quot;
                     + std::to_string(this-&gt;size());
  std::cout &lt;&lt; header &lt;&lt; std::endl;
}

template&lt;typename T&gt; std::string ArrayVector&lt;T&gt;::unsafe_to_string(const size_t first, const size_t last, const std::string &amp;after) const {
  size_t i,j,b=this-&gt;numel();
  std::string str;
  for (i=first;i&lt;last;i++){
    for (j=0;j&lt;b;j++) {
      str += my_to_string( this-&gt;getvalue(i,j) );
      // if ( str.find_last_not_of(&#39;.&#39;) ){
      //   str.erase ( str.find_last_not_of(&#39;0&#39;) + 1, std::string::npos );
      //   str.erase ( str.find_last_not_of(&#39;.&#39;) + 1, std::string::npos );
      // }
      str += &quot; &quot;;
    }
    str += after;
  }
  return str;
}
template&lt;typename T&gt; std::string ArrayVector&lt;T&gt;::to_string() const {
  return this-&gt;unsafe_to_string(0,this-&gt;size(),&quot;\n&quot;);
}
template&lt;typename T&gt; std::string ArrayVector&lt;T&gt;::to_string(const size_t i) const {
  return this-&gt;unsafe_to_string(i,i+1,&quot;&quot;);
}
template&lt;typename T&gt; std::string ArrayVector&lt;T&gt;::to_string(const std::string &amp;after) const {
  return this-&gt;unsafe_to_string(0,this-&gt;size(), after);
}
template&lt;typename T&gt; std::string ArrayVector&lt;T&gt;::to_string(const size_t i, const std::string &amp;after) const {
  return this-&gt;unsafe_to_string(i,i+1, after);
}
template&lt;typename T&gt; std::string ArrayVector&lt;T&gt;::to_string(const size_t first, const size_t last, const std::string &amp;after) const {
  if (first&lt;this-&gt;size() &amp;&amp; last&lt;this-&gt;size())
    return this-&gt;unsafe_to_string(first,last+1,after);
  std::string msg = &quot;Attempted to print elements &quot; + std::to_string(first)
                  + &quot; to &quot; + std::to_string(last) + &quot; of size(&quot;
                  + std::to_string(this-&gt;size()) + &quot;)&quot;
                  + &quot; ArrayVector!&quot;;
  throw std::domain_error(msg);
}
template&lt;typename T&gt; template&lt;class R&gt; std::string ArrayVector&lt;T&gt;::to_string(const ArrayVector&lt;R&gt;&amp; other, const size_t num) const {
  if (other.size() != this-&gt;size())
    throw std::runtime_error(&quot;ArrayVector::to_string : Equal-length ArrayVectors required.&quot;);
  size_t n = (num &amp;&amp; num&lt;this-&gt;size()) ? num : this-&gt;size();
  std::string s;
  for (size_t i=0; i&lt;n; ++i){
    for (size_t j=0; j&lt;other.numel(); ++j)
      s += my_to_string(other.getvalue(i,j)) + &quot; &quot;;
    s += &quot; &quot;;
    for (size_t j=0; j&lt;this-&gt;numel(); ++j)
      s += my_to_string(this-&gt;getvalue(i,j)) + &quot; &quot;;
    s += &quot;\n&quot;;
  }
  return s;
}

template&lt;typename T&gt; size_t ArrayVector&lt;T&gt;::resize(size_t newsize){
  bool std = (newsize*this-&gt;numel())&gt;0;
  T * newdata = nullptr;
  // allocate a new block of memory
  if (std) newdata = new T[newsize*this-&gt;numel()]();;
  if (this-&gt;size() &amp;&amp; this-&gt;numel()) { // copy-over _data :(
    size_t smallerN = (this-&gt;size() &lt; newsize) ? this-&gt;size() : newsize;
    for (size_t i=0; i&lt;smallerN*this-&gt;numel(); i++) newdata[i] = this-&gt;_data[i];
    // hand-back the chunk of memory which _data points to
    delete[] this-&gt;_data;
  }
  // and set _data to the newdata pointer;
  this-&gt;N = newsize;
  if (std) this-&gt;_data = newdata;
  return newsize;
}
template&lt;typename T&gt; size_t ArrayVector&lt;T&gt;::refresh(size_t newnumel, size_t newsize){
  // first off, remove the old _data block, if it exists
  if (this-&gt;size() &amp;&amp; this-&gt;numel())  delete[] this-&gt;_data;
  bool std = (newsize*newnumel)&gt;0;
  T * newdata = nullptr;
  // allocate a new block of memory
  if (std) newdata = new T[newsize*newnumel]();
  // and set _data to the newdata pointer;
  this-&gt;M = newnumel;
  this-&gt;N = newsize;
  this-&gt;_data = std ? newdata : nullptr;
  return newnumel*newsize;
}


template&lt;typename T&gt; template&lt;typename R&gt; bool ArrayVector&lt;T&gt;::isapprox(const ArrayVector&lt;R&gt; &amp;that) const {
  AVSizeInfo si = this-&gt;consistency_check(that);
  if (si.scalara^si.scalarb) return false; // only one is an &quot;ArrayScalar&quot;
  bool c, u;
  T Tt;
  R Rt;
  std::tie(c,u,Tt,Rt) = determine_tols&lt;T,T&gt;();
  for (size_t i=0; i&lt;si.n; i++) for (size_t j=0; j&lt;si.m; j++)
    if ( !_approx_scalar(this-&gt;getvalue(si.oneveca?0:i,j), that.getvalue(si.onevecb?0:i,si.singular?0:j), u,Tt,Rt) )
      return false;
  return true;
}
template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::isapprox(const size_t i, const size_t j) const {
  return approx_vector(this-&gt;numel(), this-&gt;data(i), this-&gt;data(j));
  // for (size_t k=0; k&lt;this-&gt;numel(); k++) if (!approx_scalar(this-&gt;getvalue(i,k),this-&gt;getvalue(j,k))) return false;
  // return true;
}

template&lt;typename T&gt; void ArrayVector&lt;T&gt;::cross(const size_t i, const size_t j, T* out) const {
  if (this-&gt;numel()!=3u){
    throw std::domain_error(&quot;cross is only defined for 3-D vectors&quot;);
  }
  if (i&lt;this-&gt;size()&amp;&amp;j&lt;this-&gt;size())  vector_cross(out,this-&gt;data(i,0),this-&gt;data(j,0));
  else {
    std::string msg = &quot;Attempted to access elements &quot; + std::to_string(i);
    msg += &quot; and &quot; + std::to_string(j) + &quot; of a &quot; + std::to_string(this-&gt;size());
    msg += &quot;-element ArrayVector&quot;;
    throw std::out_of_range(msg);
  }
}
template&lt;typename T&gt; T ArrayVector&lt;T&gt;::dot(const size_t i, const size_t j) const {
  T out = 0;
  for (size_t k=0; k&lt;this-&gt;numel(); k++) out += this-&gt;getvalue(i,k)*this-&gt;getvalue(j,k);
  return out;
}
template&lt;typename T&gt; T ArrayVector&lt;T&gt;::norm(const size_t i) const {
  return sqrt(this-&gt;dot(i,i));
}


template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::all_true(const size_t n) const {
  size_t upto = (n&gt;0 &amp;&amp; n &lt;= this-&gt;size()) ? n : this-&gt;size();
  for (size_t i=0; i&lt;upto; i++)
    for (size_t j=0; j&lt;this-&gt;numel(); j++)
      if (!this-&gt;getvalue(i,j)) return false;
  return true;
}
template&lt;typename T&gt; size_t ArrayVector&lt;T&gt;::count_true(const size_t n) const {
  size_t upto = (n&gt;0 &amp;&amp; n &lt;= this-&gt;size()) ? n : this-&gt;size();
  size_t count = 0;
  for (size_t i=0; i&lt;upto; i++)
    for (size_t j=0; j&lt;this-&gt;numel(); j++)
      if (this-&gt;getvalue(i,j)) ++count;
  return count;
}
template&lt;typename T&gt; size_t ArrayVector&lt;T&gt;::first_true(const size_t n) const {
  size_t upto = (n&gt;0 &amp;&amp; n &lt;= this-&gt;size()) ? n : this-&gt;size();
  for (size_t i=0; i&lt;upto; i++)
    for (size_t j=0; j&lt;this-&gt;numel(); j++)
      if (this-&gt;getvalue(i,j)) return i;
  return upto; // an invalid indexing
}
template&lt;typename T&gt; size_t ArrayVector&lt;T&gt;::last_true(const size_t n) const {
  size_t upto = (n&gt;0 &amp;&amp; n &lt;= this-&gt;size()) ? n : this-&gt;size();
  for (size_t i=upto; i--;) // evaluates for i=0, then stops
    for (size_t j=0; j&lt;this-&gt;numel(); j++)
      if (this-&gt;getvalue(i,j)) return i;
  return upto; // an invalid indexing
}
template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::any_true(const size_t n) const {
  size_t upto = (n&gt;0 &amp;&amp; n &lt;= this-&gt;size()) ? n : this-&gt;size();
  for (size_t i=0; i&lt;upto; i++)
    for (size_t j=0; j&lt;this-&gt;numel(); j++)
      if (this-&gt;getvalue(i,j)) return true;
  return false;
}
// template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::all_positive(const size_t n) const {
//   size_t upto = (n&gt;0 &amp;&amp; n &lt;= this-&gt;size()) ? n : this-&gt;size();
//   for (size_t i=0; i&lt;upto; i++)
//     for (size_t j=0; j&lt;this-&gt;numel(); j++)
//       if (this-&gt;getvalue(i,j)&lt;0) return false;
//   return true;
// }
template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::all_zero(const size_t n) const {
  size_t upto = (n&gt;0 &amp;&amp; n &lt;= this-&gt;size()) ? n : this-&gt;size();
  for (size_t i=0; i&lt;upto; i++)
    for (size_t j=0; j&lt;this-&gt;numel(); j++)
      if (this-&gt;getvalue(i,j)) return false;
  return true;
}
template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::all_approx(const T val, const size_t n) const {
  size_t upto = (n&gt;0 &amp;&amp; n &lt;= this-&gt;size()) ? n : this-&gt;size();
  bool c, u;
  T Tt, Rt;
  std::tie(c,u,Tt,Rt) = determine_tols&lt;T,T&gt;();
  for (size_t i=0; i&lt;upto; i++) for (size_t j=0; j&lt;this-&gt;numel(); j++)
    if (!_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt)) return false;
  return true;
}
template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::none_approx(const T val, const size_t n) const{
  size_t upto = (n&gt;0 &amp;&amp; n&lt;=this-&gt;size()) ? n : this-&gt;size();
  bool c, u;
  T Tt, Rt;
  std::tie(c,u,Tt,Rt) = determine_tols&lt;T,T&gt;();
  for (size_t i=0; i&lt;upto; ++i)
  for (size_t j=0; j&lt;this-&gt;numel(); ++j)
  if (_approx_scalar(this-&gt;getvalue(i,j), val,u,Tt,Rt)) return false;
  return true;
}
template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::all_approx(const Comp expr, const T val, const size_t n) const{
  size_t upto = (n&gt;0 &amp;&amp; n&lt;=this-&gt;size()) ? n : this-&gt;size();
  bool c, u;
  T Tt, Rt;
  std::tie(c,u,Tt,Rt) = determine_tols&lt;T,T&gt;();
  switch (expr){
    case Comp::lt:{
    for (size_t i=0; i&lt;upto; ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j)
    if (_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt) || this-&gt;getvalue(i,j) &gt; val) return false;
    return true;}
    case Comp::gt:{
    for (size_t i=0; i&lt;upto; ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j)
    if (_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt) || this-&gt;getvalue(i,j) &lt; val) return false;
    return true;}
    case Comp::le:{
    for (size_t i=0; i&lt;upto; ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j)
    if (!_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt) &amp;&amp; this-&gt;getvalue(i,j) &gt; val) return false;
    return true;}
    case Comp::ge:{
    for (size_t i=0; i&lt;upto; ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j)
    if (!_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt) &amp;&amp; this-&gt;getvalue(i,j) &lt; val) return false;
    return true;}
    case Comp::nle:{
    size_t n_approx=0, n_more=0;
    for (size_t i=0; i&lt;upto; ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j)
    if (_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt)) ++n_approx;
    else if (this-&gt;getvalue(i,j) &gt; val)  ++n_more;
    return (n_more &gt; 0 || n_approx==upto);}
    case Comp::nge:{
    size_t n_approx=0, n_less=0;
    for (size_t i=0; i&lt;upto; ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j)
    if (_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt)) ++n_approx;
    else if (this-&gt;getvalue(i,j) &lt; val)  ++n_less;
    return (n_less &gt; 0 || n_approx==upto);}
    case Comp::eq:{
    for (size_t i=0; i&lt;upto; ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j)
    if (!_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt)) return false;
    return true;
    case Comp::le_ge:
    bool allle=true, allge=true, ijneq;
    for (size_t i=0; i&lt;upto; ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j){
      ijneq = !_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt);
      if (allle &amp;&amp; ijneq &amp;&amp; this-&gt;getvalue(i,j) &gt; val) allle = false;
      if (allge &amp;&amp; ijneq &amp;&amp; this-&gt;getvalue(i,j) &lt; val) allge = false;
      if (!(allle||allge)) return false;
    }
    return true;}
    default:
    std::string msg = __PRETTY_FUNCTION__;
    msg += &quot;: Unknown comparator&quot;;
    throw std::runtime_error(msg);
  }
}
template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::any_approx(const Comp expr, const T val, const size_t n) const{
  size_t upto = (n&gt;0 &amp;&amp; n&lt;=this-&gt;size()) ? n : this-&gt;size();
  bool c, u;
  T Tt, Rt;
  std::tie(c,u,Tt,Rt) = determine_tols&lt;T,T&gt;();
  switch(expr){
    case Comp::lt:
    for (size_t i=0; i&lt;upto; ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j)
    if (!_approx_scalar(this-&gt;getvalue(i,j), val, u, Tt, Rt) &amp;&amp; this-&gt;getvalue(i,j) &lt; val) return true;
    break;
    case Comp::gt:
    for (size_t i=0; i&lt;upto; ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j)
    if (!_approx_scalar(this-&gt;getvalue(i,j), val, u, Tt, Rt) &amp;&amp; this-&gt;getvalue(i,j) &gt; val) return true;
    break;
    case Comp::le:
    for (size_t i=0; i&lt;upto; ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j)
    if (_approx_scalar(this-&gt;getvalue(i,j), val, u, Tt, Rt) || this-&gt;getvalue(i,j) &lt; val) return true;
    break;
    case Comp::ge:
    for (size_t i=0; i&lt;upto; ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j)
    if (_approx_scalar(this-&gt;getvalue(i,j), val, u, Tt, Rt) || this-&gt;getvalue(i,j) &lt; val) return true;
    break;
    case Comp::eq:
    for (size_t i=0; i&lt;upto; ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j)
    if (_approx_scalar(this-&gt;getvalue(i,j), val, u, Tt, Rt)) return true;
    break;
    default:
    std::string msg = __PRETTY_FUNCTION__;
    msg += &quot;: Unknown comparator&quot;;
    throw std::runtime_error(msg);
  }
  return false;
}
template&lt;typename T&gt; ArrayVector&lt;bool&gt; ArrayVector&lt;T&gt;::is_approx(const Comp expr, const T val, const size_t n) const{
  size_t upto = (n&gt;0 &amp;&amp; n&lt;=this-&gt;size()) ? n : this-&gt;size();
  ArrayVector&lt;bool&gt; out(1u, this-&gt;size());
  for (size_t i=0; i&lt;this-&gt;size(); ++i) out.insert(false, i);
  bool onearray, c, u;
  T Tt, Rt;
  std::tie(c,u,Tt,Rt) = determine_tols&lt;T,T&gt;();
  switch (expr){
    case Comp::lt: for (size_t i=0; i&lt;upto; ++i){
      onearray = true;
      for (size_t j=0; j&lt;this-&gt;numel(); ++j)
      if (_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt) || this-&gt;getvalue(i,j) &gt; val)
        onearray = false;
      out.insert(onearray, i);
    } break;
    case Comp::gt: for (size_t i=0; i&lt;upto; ++i){
      onearray = true;
      for (size_t j=0; j&lt;this-&gt;numel(); ++j)
      if (_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt) || this-&gt;getvalue(i,j) &lt; val)
        onearray = false;
      out.insert(onearray, i);
    } break;
    case Comp::le: for (size_t i=0; i&lt;upto; ++i){
      onearray = true;
      for (size_t j=0; j&lt;this-&gt;numel(); ++j)
      if (!_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt) &amp;&amp; this-&gt;getvalue(i,j) &gt; val)
        onearray = false;
      out.insert(onearray, i);
    } break;
    case Comp::ge: for (size_t i=0; i&lt;upto; ++i){
      onearray = true;
      for (size_t j=0; j&lt;this-&gt;numel(); ++j)
      if (!_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt) &amp;&amp; this-&gt;getvalue(i,j) &lt; val)
        onearray = false;
      out.insert(onearray, i);
    } break;
    case Comp::eq: for (size_t i=0; i&lt;upto; ++i){
      onearray = true;
      for (size_t j=0; j&lt;this-&gt;numel(); ++j)
      if (!_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt))
        onearray = false;
      out.insert(onearray, i);
    } break;
    case Comp::neq: for (size_t i=0; i&lt;upto; ++i){
      onearray = true;
      for (size_t j=0; j&lt;this-&gt;numel(); ++j)
      if (_approx_scalar(this-&gt;getvalue(i,j), val, u,Tt,Rt))
        onearray = false;
      out.insert(onearray, i);
    } break;
    default:
    std::string msg = __PRETTY_FUNCTION__;
    msg += &quot;: Unknown comparator&quot;;
    throw std::runtime_error(msg);
  }
  return out;
}
template&lt;typename T&gt; ArrayVector&lt;bool&gt; ArrayVector&lt;T&gt;::is_approx(const Comp expr, const std::vector&lt;T&gt;&amp; vals) const{
  size_t n = vals.size();
  size_t upto = (n&gt;0 &amp;&amp; n&lt;=this-&gt;size()) ? n : this-&gt;size();
  ArrayVector&lt;bool&gt; out(1u, this-&gt;size());
  for (size_t i=0; i&lt;this-&gt;size(); ++i) out.insert(false, i);
  bool onearray, c, u;
  T Tt, Rt;
  std::tie(c,u,Tt,Rt) = determine_tols&lt;T,T&gt;();
  switch(expr){
    case Comp::lt: for (size_t i=0; i&lt;upto; ++i){
      onearray = true;
      for (size_t j=0; j&lt;this-&gt;numel(); ++j)
      if (_approx_scalar(this-&gt;getvalue(i,j), vals[i], u,Tt,Rt) || this-&gt;getvalue(i,j) &gt; vals[i])
      onearray = false;
      out.insert(onearray, i);
    } break;
    case Comp::gt: for (size_t i=0; i&lt;upto; ++i){
      onearray = true;
      for (size_t j=0; j&lt;this-&gt;numel(); ++j)
      if (_approx_scalar(this-&gt;getvalue(i,j), vals[i], u,Tt,Rt) || this-&gt;getvalue(i,j) &lt; vals[i])
      onearray = false;
      out.insert(onearray, i);
    } break;
    case Comp::le: for (size_t i=0; i&lt;upto; ++i){
      onearray = true;
      for (size_t j=0; j&lt;this-&gt;numel(); ++j)
      if (!_approx_scalar(this-&gt;getvalue(i,j), vals[i], u,Tt,Rt) &amp;&amp; this-&gt;getvalue(i,j) &gt; vals[i])
      onearray = false;
      out.insert(onearray, i);
    } break;
    case Comp::ge: for (size_t i=0; i&lt;upto; ++i){
      onearray = true;
      for (size_t j=0; j&lt;this-&gt;numel(); ++j)
      if (!_approx_scalar(this-&gt;getvalue(i,j), vals[i], u,Tt,Rt) &amp;&amp; this-&gt;getvalue(i,j) &lt; vals[i])
      onearray = false;
      out.insert(onearray, i);
    } break;
    case Comp::eq: for (size_t i=0; i&lt;upto; ++i){
      onearray = true;
      for (size_t j=0; j&lt;this-&gt;numel(); ++j)
      if (!_approx_scalar(this-&gt;getvalue(i,j), vals[i], u,Tt,Rt))
      onearray = false;
      out.insert(onearray, i);
    } break;
    case Comp::neq: for (size_t i=0; i&lt;upto; ++i){
      onearray = true;
      for (size_t j=0; j&lt;this-&gt;numel(); ++j)
      if (_approx_scalar(this-&gt;getvalue(i,j), vals[i], u,Tt,Rt))
      onearray = false;
      out.insert(onearray, i);
    } break;
    default:
    std::string msg = __PRETTY_FUNCTION__;
    msg += &quot;: Unknown comparator&quot;;
    throw std::runtime_error(msg);
  }
  return out;
}

template&lt;typename T&gt; bool ArrayVector&lt;T&gt;::vector_approx(const size_t i, const size_t j, const Comp op, const T val) const{
  if (i&gt;=this-&gt;size() || j&gt;=this-&gt;size())
    throw std::out_of_range(&quot;ArrayVector range indices out of range&quot;);
  bool ok = true, c, u;
  T Tt, Rt;
  std::tie(c,u,Tt,Rt) = determine_tols&lt;T,T&gt;();
  switch (op){
    case Comp::plus:
    for (size_t k=0; k&lt;this-&gt;numel(); ++k)
    if(!_approx_scalar(this-&gt;getvalue(i,k),this-&gt;getvalue(j,k)+val,u,Tt,Rt)) ok = false;
    return ok;
    case Comp::minus:
    for (size_t k=0; k&lt;this-&gt;numel(); ++k)
    if(!_approx_scalar(this-&gt;getvalue(i,k),this-&gt;getvalue(j,k)-val,u,Tt,Rt)) ok = false;
    return ok;
    case Comp::times:
    for (size_t k=0; k&lt;this-&gt;numel(); ++k)
    if(!_approx_scalar(this-&gt;getvalue(i,k),this-&gt;getvalue(j,k)*val,u,Tt,Rt)) ok = false;
    return ok;
    case Comp::rdiv:
    for (size_t k=0; k&lt;this-&gt;numel(); ++k)
    if(!_approx_scalar(this-&gt;getvalue(i,k),this-&gt;getvalue(j,k)/val,u,Tt,Rt)) ok = false;
    return ok;
    case Comp::ldiv:
    for (size_t k=0; k&lt;this-&gt;numel(); ++k)
    if(!_approx_scalar(this-&gt;getvalue(i,k),val/this-&gt;getvalue(j,k),u,Tt,Rt)) ok = false;
    return ok;
    case Comp::eq:
    for (size_t k=0; k&lt;this-&gt;numel(); ++k)
    if (!_approx_scalar(this-&gt;getvalue(i,k), this-&gt;getvalue(j,k),u,Tt,Rt)) ok = false;
    return ok;
    default:
    std::string msg = __PRETTY_FUNCTION__;
    msg += &quot;: Unknown operator&quot;;
    throw std::runtime_error(msg);
  }
}
template&lt;typename T&gt; template&lt;class R, size_t Nel&gt;
bool ArrayVector&lt;T&gt;::rotate_approx(const size_t i, const size_t j, const std::array&lt;R,Nel&gt;&amp; mat, const int order) const{
  // if (!std::is_convertible&lt;typename std::common_type&lt;T,R&gt;,T&gt;::value)
  //   throw std::runtime_error(&quot;Incompatible types.&quot;);
  size_t n = this-&gt;numel();
  if (Nel != n*n)
    throw std::runtime_error(&quot;Wrong size matrix input.&quot;);
  if (i&gt;=this-&gt;size() || j&gt;=this-&gt;size())
    throw std::out_of_range(&quot;ArrayVector range indices out of range&quot;);
  std::vector&lt;T&gt; tmpA(n), tmpB(n);
  for (size_t k=0; k&lt;n; ++k) tmpA[k] = this-&gt;getvalue(j,k);
  bool same = true, c, u;
  T Tt, Rt;
  std::tie(c,u,Tt,Rt) = determine_tols&lt;T,T&gt;();
  if (order&lt;0){
    int o=0;
    do{
      same = true;
      // check against the current tmp vector whether this order rotations has
      // moved j to i -- if it has, same stays true and we can return true
      for (size_t k=0; k&lt;n; ++k) if (!_approx_scalar(this-&gt;getvalue(i,k), tmpA[k],u,Tt,Rt)) same = false;
      if (same) return true;
      // otherwise we need to perform the next rotation
      mul_mat_vec(tmpB.data(), n, mat.data(), tmpA.data());
      // and assign the rotated vector back to the first temporary array
      tmpA = tmpB;
    } while (o++&lt;std::abs(order)); // check if v[j], Rv[j], R²v[j], …, Rᵒ⁻¹v[j] ≡ v[i]
    return same;
  } else {
    // rotate exactly order times
    for (int o=0; o&lt;order; ++o){
      mul_mat_vec(tmpB.data(), n, mat.data(), tmpA.data());
      tmpA = tmpB;
    }
    for (size_t k=0; k&lt;n; ++k) if (!_approx_scalar(this-&gt;getvalue(i,k), tmpA[k],u,Tt,Rt)) same = false;
    return same;
  }
}

template&lt;typename T&gt; ArrayVector&lt;int&gt; ArrayVector&lt;T&gt;::round() const{
  ArrayVector&lt;int&gt; out(this-&gt;numel(),this-&gt;size());
  for (size_t i=0; i&lt;this-&gt;size(); i++)
    for (size_t j=0; j&lt;this-&gt;numel(); j++)
      out.insert( (int)std::round(this-&gt;getvalue(i,j)), i,j);
  return out;
}
template&lt;typename T&gt; ArrayVector&lt;int&gt; ArrayVector&lt;T&gt;::floor() const{
  ArrayVector&lt;int&gt; out(this-&gt;numel(),this-&gt;size());
  for (size_t i=0; i&lt;this-&gt;size(); i++)
    for (size_t j=0; j&lt;this-&gt;numel(); j++)
      out.insert( std::floor(this-&gt;getvalue(i,j)), i,j);
  return out;
}
template&lt;typename T&gt; ArrayVector&lt;int&gt; ArrayVector&lt;T&gt;::ceil() const{
  ArrayVector&lt;int&gt; out(this-&gt;numel(),this-&gt;size());
  for (size_t i=0; i&lt;this-&gt;size(); i++)
    for (size_t j=0; j&lt;this-&gt;numel(); j++)
      out.insert( std::ceil(this-&gt;getvalue(i,j)), i,j);
  return out;
}

template&lt;typename T&gt; ArrayVector&lt;T&gt; ArrayVector&lt;T&gt;::sum( const int dim ) const {
  T tmp;
  ArrayVector&lt;T&gt; out;
  switch (dim){
    case 1:
      out.refresh(1u,this-&gt;size());
      for (size_t i=0; i&lt;this-&gt;size(); i++){
        tmp = T(0);
        for (size_t j=0; j&lt;this-&gt;numel(); j++) tmp += this-&gt;getvalue(i,j);
        out.insert(tmp, i,0);
      }
      break;
    default:
      out.refresh(this-&gt;numel(),1u);
      for (size_t j=0; j&lt;this-&gt;numel(); j++){
        tmp = T(0);
        for (size_t i=0; i&lt;this-&gt;size(); i++) tmp += this-&gt;getvalue(i,j);
        out.insert(tmp, 0,j);
      }
      break;
  }
  return out;
}
template&lt;typename T&gt; ArrayVector&lt;T&gt; ArrayVector&lt;T&gt;::prod( const int dim ) const {
  T tmp;
  ArrayVector&lt;T&gt; out;
  switch (dim){
    case 1:
      out.refresh(1u,this-&gt;size());
      for (size_t i=0; i&lt;this-&gt;size(); i++){
        tmp = T(1);
        for (size_t j=0; j&lt;this-&gt;numel(); j++) tmp *= this-&gt;getvalue(i,j);
        out.insert(tmp, i,0);
      }
      break;
    default:
      out.refresh(this-&gt;numel(),1u);
      for (size_t j=0; j&lt;this-&gt;numel(); j++){
        tmp = T(1);
        for (size_t i=0; i&lt;this-&gt;size(); i++) tmp *= this-&gt;getvalue(i,j);
        out.insert(tmp, 0,j);
      }
      break;
  }
  return out;
}
template&lt;typename T&gt; ArrayVector&lt;T&gt; ArrayVector&lt;T&gt;::min( const int dim ) const {
  T tmp;
  ArrayVector&lt;T&gt; out;
  switch (dim){
    case 1:
      out.refresh(1u,this-&gt;size());
      for (size_t i=0; i&lt;this-&gt;size(); i++){
        tmp = (std::numeric_limits&lt;T&gt;::max)();
        for (size_t j=0; j&lt;this-&gt;numel(); j++)
        if (this-&gt;getvalue(i,j) &lt; tmp) tmp = this-&gt;getvalue(i,j);
        out.insert(tmp, i,0);
      }
      break;
    default:
      out.refresh(this-&gt;numel(),1u);
      for (size_t j=0; j&lt;this-&gt;numel(); j++){
        tmp = (std::numeric_limits&lt;T&gt;::max)();
        for (size_t i=0; i&lt;this-&gt;size(); i++)
        if (this-&gt;getvalue(i,j) &lt; tmp) tmp = this-&gt;getvalue(i,j);
        out.insert(tmp, 0,j);
      }
      break;
  }
  return out;
}
template&lt;typename T&gt; ArrayVector&lt;T&gt; ArrayVector&lt;T&gt;::max( const int dim ) const {
  T tmp;
  ArrayVector&lt;T&gt; out;
  switch (dim){
    case 1:
      out.refresh(1u,this-&gt;size());
      for (size_t i=0; i&lt;this-&gt;size(); i++){
        tmp = std::numeric_limits&lt;T&gt;::lowest();
        for (size_t j=0; j&lt;this-&gt;numel(); j++)
        if (this-&gt;getvalue(i,j) &gt; tmp) tmp = this-&gt;getvalue(i,j);
        out.insert(tmp, i,0);
      }
      break;
    default:
      out.refresh(this-&gt;numel(),1u);
      for (size_t j=0; j&lt;this-&gt;numel(); j++){
        tmp = std::numeric_limits&lt;T&gt;::lowest();
        for (size_t i=0; i&lt;this-&gt;size(); i++)
        if (this-&gt;getvalue(i,j) &gt; tmp) tmp = this-&gt;getvalue(i,j);
        out.insert(tmp, 0,j);
      }
      break;
  }
  return out;
}
template&lt;typename T&gt; ArrayVector&lt;bool&gt; ArrayVector&lt;T&gt;::is_unique(void) const{
  // assume all are unique to start
  ArrayVector&lt;bool&gt; isu(1u,this-&gt;size(),true);
  bool c, u;
  T Tt, Rt;
  std::tie(c,u,Tt,Rt) = determine_tols&lt;T,T&gt;();
  // and only check from the second array onwards against those of lower index
  for (size_t i=1; i&lt;this-&gt;size(); ++i) for (size_t j=0; j&lt;i; ++j)
  if (isu.getvalue(j) &amp;&amp; _approx_array(this-&gt;numel(), this-&gt;data(i), this-&gt;data(j), u, Tt, Rt)){
    isu.insert(false,i);
    break;
  }
  return isu;
}
template&lt;typename T&gt; ArrayVector&lt;size_t&gt; ArrayVector&lt;T&gt;::unique_idx(void) const{
  ArrayVector&lt;size_t&gt; isu(1u,this-&gt;size());
  // assume all are unique to start
  for (size_t i=0; i&lt;this-&gt;size(); ++i) isu.insert(i,i);
  bool c, u;
  T Tt, Rt;
  std::tie(c,u,Tt,Rt) = determine_tols&lt;T,T&gt;();
  // and only check from the second array onwards against those of lower index
  for (size_t i=1; i&lt;this-&gt;size(); ++i) for (size_t j=0; j&lt;i; ++j)
  if (j==isu.getvalue(j) &amp;&amp; _approx_array(this-&gt;numel(), this-&gt;data(i), this-&gt;data(j), u, Tt, Rt)){
    isu.insert(j,i);
    break;
  }
  return isu;
}

/*! Extract elements of an ArrayVector while preserving its (sub)class type */
template&lt;class T, template&lt;class&gt; class L,typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,L&lt;T&gt;&gt;::value&gt;::type&gt;
L&lt;T&gt; extract(L&lt;T&gt;&amp; source, ArrayVector&lt;bool&gt;&amp; idx){
  if (idx.numel()!=1u || idx.size() != source.size()){
    std::string msg = &quot;Extracting an ArrayVector by logical indexing requires&quot;;
    msg += &quot; an ArrayVector&lt;bool&gt; with numel()==1&quot;;
    msg += &quot; and size()==ArrayVector.size().&quot;;
    throw std::runtime_error(msg);
  }
  size_t nout=0;
  for (size_t i=0; i&lt;idx.size(); ++i) if (idx.getvalue(i,0)) ++nout;
  L&lt;T&gt; sink(source);
  sink.resize(nout);
  size_t at = 0;
  for (size_t i=0; i&lt;idx.size(); ++i)
    if (idx.getvalue(i,0)) sink.set(at++, source.data(i));
  return sink;
}
template&lt;class T, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value&gt;::type&gt;
A&lt;T&gt; unique(A&lt;T&gt;&amp; source){
  ArrayVector&lt;bool&gt; uniquesorce = source.is_unique();
  return extract(source, uniquesorce);
}

// cross (ArrayVector × ArrayVector)
template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value&amp;&amp;!std::is_base_of&lt;LatVec,A&lt;T&gt;&gt;::value&gt;::type,
         typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;R&gt;,A&lt;R&gt;&gt;::value&amp;&amp;!std::is_base_of&lt;LatVec,A&lt;R&gt;&gt;::value&gt;::type,
         class S=typename std::common_type&lt;T,R&gt;::type &gt;
A&lt;S&gt; cross(const A&lt;T&gt;&amp; a, const A&lt;R&gt;&amp; b) {
  AVSizeInfo si = a.consistency_check(b);
  if (si.m!=3u) throw std::domain_error(&quot;cross product is only defined for three vectors&quot;);
  A&lt;S&gt; out( 3u, si.n);
  for (size_t i=0; i&lt;si.n; i++)
    vector_cross&lt;S,T,R,3&gt;(out.data(i), a.data(si.oneveca?0:i), b.data(si.onevecb?0:i));
  return out;
}

// template&lt;class T, class R, template&lt;class&gt; class A,
//          typename=typename std::enable_if&lt; std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value &amp;&amp; !std::is_base_of&lt;LatVec,A&lt;T&gt;&gt;::value&gt;::type,
//          class S = typename std::common_type&lt;T,R&gt;::type
//          &gt;
// A&lt;S&gt; dot(const A&lt;T&gt;&amp; a, const A&lt;R&gt;&amp; b){
//   AVSizeInfo si = a.consistency_check(b);
//   if (si.scalara^si.scalarb)
//     throw std::runtime_error(&quot;ArrayVector dot requires equal numel()&quot;);
//   A&lt;S&gt; out(1u,si.n);
//   S d;
//   for (size_t i=0; i&lt;si.n; ++i){
//     d = S(0);
//     for (size_t j=0; j&lt;si.m; ++j)
//       d+= a.getvalue((si.oneveca ? 0 : i), j) * b.getvalue((si.onevecb ? 0 : i), j);
//     out.insert(d, i, 0);
//   }
//   return out;
// }
template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt; std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value &amp;&amp; !std::is_base_of&lt;LatVec,A&lt;T&gt;&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type
         &gt;
A&lt;S&gt; dot(const A&lt;T&gt;&amp; a, const A&lt;R&gt;&amp; b){
  AVSizeInfo si = a.consistency_check(b);
  if (si.scalara^si.scalarb)
    throw std::runtime_error(&quot;ArrayVector dot requires equal numel()&quot;);
  A&lt;S&gt; out(1u, si.n, S(0));
  S* d = out.data();
  if (si.oneveca &amp;&amp; si.onevecb){
    for (size_t j=0; j&lt;si.m; ++j) d[0] += a.getvalue(0, j) * b.getvalue(0, j);
    return out;
  }
  if (si.oneveca){
    for (size_t i=0; i&lt;si.n; ++i) for (size_t j=0; j&lt;si.m; ++j) d[i] += a.getvalue(0, j) * b.getvalue(i, j);
    return out;
  }
  if (si.onevecb){
    for (size_t i=0; i&lt;si.n; ++i) for (size_t j=0; j&lt;si.m; ++j) d[i] += a.getvalue(i, j) * b.getvalue(0, j);
    return out;
  }
  T* ad = a.data();
  R* bd = b.data();
  for (size_t i=0; i&lt;si.n; ++i) for (size_t j=0; j&lt;si.m; ++j) d[i] += ad[i*si.m+j]*bd[i*si.m+j];
  return out;
}

template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value &amp;&amp; !std::is_base_of&lt;LatVec,A&lt;T&gt;&gt;::value&gt;::type,
         typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;R&gt;,A&lt;R&gt;&gt;::value &amp;&amp; !std::is_base_of&lt;LatVec,A&lt;R&gt;&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type&gt;
A&lt;S&gt; cat(const A&lt;T&gt;&amp; a, const A&lt;R&gt;&amp; b){
  if (a.numel() != b.numel())
    throw std::runtime_error(&quot;ArrayVector cat requies equal numel()&quot;);
  A&lt;S&gt; out(a.numel(), a.size()+b.size());
  for (size_t i=0; i&lt;a.size(); ++i) for (size_t j=0; j&lt;a.numel(); ++j)
    out.insert( static_cast&lt;S&gt;(a.getvalue(i,j)), i, j);
  for (size_t i=0; i&lt;b.size(); ++i) for (size_t j=0; j&lt;b.numel(); ++j)
    out.insert( static_cast&lt;S&gt;(b.getvalue(i,j)), a.size()+i, j);
  return out;
}

template&lt;class T, template&lt;class&gt; class A, class ...Targs,
         // typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value &amp;&amp; !std::is_base_of&lt;LatVec,A&lt;T&gt;&gt;::value&gt;::type&gt;
         typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value&gt;::type&gt;
A&lt;T&gt; cat(const A&lt;T&gt;&amp; a, const A&lt;T&gt;&amp; b, const A&lt;T&gt;&amp; c, Targs ...Fargs){
  return cat(cat(a,b), c, Fargs...); // recursively concatenate
}

template&lt;class T, template&lt;class&gt; class L,typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,L&lt;T&gt;&gt;::value&gt;::type&gt;
L&lt;int&gt; round(const L&lt;T&gt;&amp; a){
  L&lt;int&gt; out(a);
  for (size_t i=0; i&lt;a.size(); i++) for (size_t j=0; j&lt;a.numel(); j++) out.insert( std::round(a.getvalue(i,j)), i,j);
  return out;
}
// floor(LatVec)
template&lt;class T, template&lt;class&gt; class L,typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,L&lt;T&gt;&gt;::value&gt;::type&gt;
L&lt;int&gt; floor(const L&lt;T&gt;&amp; a){
  L&lt;int&gt; out(a);
  for (size_t i=0; i&lt;a.size(); i++) for (size_t j=0; j&lt;a.numel(); j++) out.insert( std::floor(a.getvalue(i,j)), i,j);
  return out;
}
// ceil(LatVec)
template&lt;class T, template&lt;class&gt; class L,typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,L&lt;T&gt;&gt;::value&gt;::type&gt;
L&lt;int&gt; ceil(const L&lt;T&gt;&amp; a){
  L&lt;int&gt; out(a);
  for (size_t i=0; i&lt;a.size(); i++) for (size_t j=0; j&lt;a.numel(); j++) out.insert( std::ceil(a.getvalue(i,j)), i,j);
  return out;
}

template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value&gt;::type,
         typename=typename std::enable_if&lt;!std::is_base_of&lt;ArrayVector&lt;R&gt;,R&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type &gt;
A&lt;S&gt; operator+(const A&lt;T&gt;&amp; a, const R&amp; b){
  A&lt;S&gt; out(a);
  for (size_t i=0; i&lt;out.size(); i++) for(size_t j=0; j&lt;out.numel(); j++) out.insert( a.getvalue(i,j) + b, i,j );
  return out;
}
template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value&gt;::type,
         typename=typename std::enable_if&lt;!std::is_base_of&lt;ArrayVector&lt;R&gt;,R&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type &gt;
A&lt;S&gt; operator-(const A&lt;T&gt;&amp; a, const R&amp; b){
  A&lt;S&gt; out(a);
  for (size_t i=0; i&lt;out.size(); i++) for(size_t j=0; j&lt;out.numel(); j++) out.insert( a.getvalue(i,j) - b, i,j );
  return out;
}
template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value&gt;::type,
         typename=typename std::enable_if&lt;!std::is_base_of&lt;ArrayVector&lt;R&gt;,R&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type &gt;
A&lt;S&gt; operator*(const A&lt;T&gt;&amp; a, const R&amp; b){
  A&lt;S&gt; out(a);
  for (size_t i=0; i&lt;out.size(); i++) for(size_t j=0; j&lt;out.numel(); j++) out.insert( a.getvalue(i,j) * b, i,j );
  return out;
}
// template&lt;class T, class R, template&lt;class&gt; class A,
//          typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value&gt;::type,
//          typename=typename std::enable_if&lt;!std::is_base_of&lt;ArrayVector&lt;R&gt;,R&gt;::value&gt;::type,
//          class S = typename std::common_type&lt;T,R&gt;::type,
//          typename=typename std::enable_if&lt;std::is_floating_point&lt;S&gt;::value&gt;::type &gt;
template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value&gt;::type,
         typename=typename std::enable_if&lt;!std::is_base_of&lt;ArrayVector&lt;R&gt;,R&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type&gt; // leave off the is_floating_point restriction on S for the special case used by halfN
A&lt;S&gt; operator/(const A&lt;T&gt;&amp; a, const R&amp; b){
  A&lt;S&gt; out(a);
  for (size_t i=0; i&lt;out.size(); i++) for(size_t j=0; j&lt;out.numel(); j++) out.insert( a.getvalue(i,j) / b, i,j );
  return out;
}
template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value&gt;::type,
         typename=typename std::enable_if&lt;!std::is_base_of&lt;ArrayVector&lt;R&gt;,R&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type &gt;
A&lt;S&gt; operator+(const R&amp; b, const A&lt;T&gt;&amp; a){
  A&lt;S&gt; out(a);
  for (size_t i=0; i&lt;out.size(); i++) for(size_t j=0; j&lt;out.numel(); j++) out.insert( b + a.getvalue(i,j), i,j );
  return out;
}
template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value&gt;::type,
         typename=typename std::enable_if&lt;!std::is_base_of&lt;ArrayVector&lt;R&gt;,R&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type &gt;
A&lt;S&gt; operator-(const R&amp; b, const A&lt;T&gt;&amp; a){
  A&lt;S&gt; out(a);
  for (size_t i=0; i&lt;out.size(); i++) for(size_t j=0; j&lt;out.numel(); j++) out.insert( b - a.getvalue(i,j), i,j );
  return out;
}
template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value&gt;::type,
         typename=typename std::enable_if&lt;!std::is_base_of&lt;ArrayVector&lt;R&gt;,R&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type &gt;
A&lt;S&gt; operator*(const R&amp; b, const A&lt;T&gt;&amp; a){
  A&lt;S&gt; out(a);
  for (size_t i=0; i&lt;out.size(); i++) for(size_t j=0; j&lt;out.numel(); j++) out.insert( b * a.getvalue(i,j), i,j );
  return out;
}
template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt;std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value&gt;::type,
         typename=typename std::enable_if&lt;!std::is_base_of&lt;ArrayVector&lt;R&gt;,R&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type,
         typename=typename std::enable_if&lt;std::is_floating_point&lt;S&gt;::value&gt;::type &gt;
A&lt;S&gt; operator/(const R&amp; b, const A&lt;T&gt;&amp; a){
  A&lt;S&gt; out(a);
  for (size_t i=0; i&lt;out.size(); i++) for(size_t j=0; j&lt;out.numel(); j++) out.insert( b / a.getvalue(i,j), i,j );
  return out;
}


template&lt;typename T&gt; ArrayVector&lt;T&gt; ArrayVector&lt;T&gt;:: operator -() const {
  ArrayVector&lt;T&gt; out(this-&gt;numel(),this-&gt;size());
  for (size_t i=0; i&lt;(this-&gt;numel()*this-&gt;size()); i++) out._data[i] = -(this-&gt;_data[i]);
  return out;
}


/*! Combine multiple arrays from one ArrayVector into a single-array ArrayVector
  @param av The ArrayVector from which arrays will be extracted
  @param n The number of arrays to be extraced
  @param i A pointer to the indices of the arrays to be extracted
  @returns a single-array ArrayVector with elements that are the sum of the
           extracted arrays&#39; elements
*/
template&lt;typename T&gt; ArrayVector&lt;T&gt; accumulate(const ArrayVector&lt;T&gt;&amp; av, const size_t n, const size_t *i) {
  ArrayVector&lt;T&gt; out(av.numel(),1u);
  // for (size_t j=0; j&lt;av.numel(); ++j) out.insert(T(0), 0,j);
  for (size_t j=0; j&lt;n; j++) out += av.extract(i[j]);
  return out;
}
/*! Combine multiple weighted arrays from one ArrayVector into a single-array ArrayVector
  @param av The ArrayVector from which arrays will be extracted
  @param n The number of arrays to be extraced
  @param i A pointer to the indices of the arrays to be extracted
  @param w A pointer to the weights used in combining the extracted arrays
  @returns a single-array ArrayVector with elements that are the weighted sum
           of the extracted arrays&#39; elements
*/
template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt; std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value &amp;&amp; !std::is_base_of&lt;LatVec,A&lt;T&gt;&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type
         &gt;
A&lt;S&gt; accumulate(const A&lt;T&gt;&amp; av, const size_t n, const size_t *i, const R *w) {
  A&lt;S&gt; out(av.numel(),1u);
  // for (size_t j=0; j&lt;av.numel(); ++j) out.insert(S(0), 0,j);
  for (size_t j=0; j&lt;n; j++) out += av.extract(i[j]) *w[j];
  return out;
}
/*! Combine multiple weighted arrays from one ArrayVector into a single-array ArrayVector,
    storing the result in the specified ArrayVector at the specified index
  @param av The ArrayVector from which arrays will be extracted
  @param n The number of arrays to be extraced
  @param i A pointer to the indices of the arrays to be extracted
  @param w A pointer to the weights used in combining the extracted arrays
  @param[out] out A reference to the ArrayVector where the result will be stored
  @param j The index into out where the array will be stored
*/
template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt; std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value &amp;&amp; !std::is_base_of&lt;LatVec,A&lt;T&gt;&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type
         &gt;
void accumulate_to(const A&lt;T&gt;&amp; av, const size_t n, const size_t *i, const R *w, A&lt;S&gt;&amp; out, const size_t j) {
  if (av.numel() != out.numel()){
    throw std::runtime_error(&quot;source and sink ArrayVectors must have same number of elements&quot;);
  }
  if ( j &gt;= out.size() ){
    throw std::out_of_range(&quot;sink index out of range&quot;);
  }
  for (size_t k=0;k&lt;n;++k) if (i[k]&gt;=av.size()){
    throw std::out_of_range(&quot;source index out of range&quot;);
  }
  unsafe_accumulate_to(av,n,i,w,out,j);
}
/*! Combine multiple weighted arrays from one ArrayVector into a single-array ArrayVector,
    storing the result in the specified ArrayVector at the specified index
  @param av The ArrayVector from which arrays will be extracted
  @param n The number of arrays to be extraced
  @param i A pointer to the indices of the arrays to be extracted
  @param w A pointer to the weights used in combining the extracted arrays
  @param[out] out A reference to the ArrayVector where the result will be stored
  @param j The index into out where the array will be stored
  @note This function performs no bounds checking. Use accumulate_to if there is
        a need to ensure no out-of-bounds access is performed.
*/
template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt; std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value &amp;&amp; !std::is_base_of&lt;LatVec,A&lt;T&gt;&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type
         &gt;
void unsafe_accumulate_to(const A&lt;T&gt;&amp; av, const size_t n, const size_t *i, const R *w, A&lt;S&gt;&amp; out, const size_t j) {
  S *outdata = out.data(j);
  size_t m=av.numel();
  for (size_t x=0; x&lt;n; ++x){
    T *avidata = av.data(i[x]);
    for (size_t y=0; y&lt;m; ++y)
      outdata[y] += avidata[y]*w[x];
  }
}


/*! Combine multiple weighted arrays from one ArrayVector into a single-array ArrayVector,
    treating the elements of each vector as a series of scalars, eigenvectors,
    vectors, and matrices,
    storing the result in the specified ArrayVector at the specified index
  @param av The ArrayVector from which arrays will be extracted
  @param nS The number of scalar elements
  @param nE The number of eigenvector elements
  @param nV The number of vector elements
  @param nM The number of matrix elements
  @param nB The number of branches per array
  @param n The number of arrays to be extraced
  @param i A pointer to the indices of the arrays to be extracted
  @param w A pointer to the weights used in combining the extracted arrays
  @param[out] out A reference to the ArrayVector where the result will be stored
  @param j The index into out where the array will be stored
*/
template&lt;class T, class R, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt; std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value &amp;&amp; !std::is_base_of&lt;LatVec,A&lt;T&gt;&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type
         &gt;
void interpolate_to(const A&lt;T&gt;&amp; av,
                    const std::array&lt;unsigned,4&gt;&amp; Nel,
                    const size_t nB,
                    const size_t n,
                    const size_t *i,
                    const R *w,
                    A&lt;S&gt;&amp; out,
                    const size_t j) {
  if (av.numel() != out.numel()){
    throw std::runtime_error(&quot;source and sink ArrayVectors must have same number of elements&quot;);
  }
  if ( j &gt;= out.size() ){
    throw std::out_of_range(&quot;sink index out of range&quot;);
  }
  if (av.numel() != (Nel[0]+Nel[1]+Nel[2]+Nel[3]*Nel[3])*nB){
    throw std::runtime_error(&quot;Wrong number of scalar/eigenvector/vector/matrix elements or branches.&quot;);
  }
  for (size_t k=0;k&lt;n;++k) if (i[k]&gt;=av.size()){
    throw std::out_of_range(&quot;source index out of range&quot;);
  }
  unsafe_interpolate_to(av,Nel,nB,n,i,w,out,j);
}
template&lt;class T, class R, class I, template&lt;class&gt; class A,
    typename=typename std::enable_if&lt; std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value &amp;&amp; !std::is_base_of&lt;LatVec,A&lt;T&gt;&gt;::value&gt;::type,
    class S = typename std::common_type&lt;T,R&gt;::type
&gt;
void unsafe_interpolate_to(const A&lt;T&gt;&amp; source,
                           const std::array&lt;I,3&gt;&amp; Nel,
                           const size_t Nobj,
                           const size_t Narr,
                           const size_t *Isrc,
                           const R *weights,   /*&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;!!!!!!!!!!!!!!!!!!!!!!! THIS IS WHY THERE ARE TWO VERSION OF unsafe_interpolate_to!!!!!!!!!!!!!!*/
                           A&lt;T&gt;&amp; sink,
                           const size_t Jsnk) {
  info_update(&quot;The function unsafe_interpolate_to should not be used any longer. Please move to the new InterpolationData class&quot;);
  T *sink_j = sink.data(Jsnk);
  T *source_0 = source.data(Isrc[0]);
  size_t offset, span = static_cast&lt;size_t&gt;(Nel[0])+static_cast&lt;size_t&gt;(Nel[1])+static_cast&lt;size_t&gt;(Nel[2]);
  T e_i_theta;
  for (size_t x=0; x&lt;Narr; ++x){
    T *source_i = source.data(Isrc[x]);
    // loop over the modes. they are the first index and farthest in memory
    for (size_t Iobj=0; Iobj&lt;Nobj; ++Iobj){
      // Scalars are first, nothing special to do:
      for (size_t Iscl=0; Iscl&lt;Nel[0]; ++Iscl)
        sink_j[Iobj*span + Iscl] += weights[x]*source_i[Iobj*span + Iscl];
      if (Nel[1]){
        // Eigenvectors are next
        offset = Iobj*span + Nel[0];
        // find the arbitrary phase eⁱᶿ between different-object eigenvectors
        e_i_theta = antiphase(hermitian_product(Nel[1], source_0+offset, source_i+offset));
        // remove the arbitrary phase as we add the weighted value
        for(size_t Jeig=0; Jeig&lt;Nel[1]; ++Jeig)
          sink_j[offset + Jeig] += weights[x]*(e_i_theta*source_i[offset+Jeig]);
      }
      // Vector and Matrix parts of each object are treated as scalars:
      for (size_t Ivecmat = Nel[0]+Nel[1]; Ivecmat&lt;span; ++Ivecmat)
        sink_j[Iobj*span + Ivecmat] += weights[x]*source_i[Iobj*span + Ivecmat];
    }
  }
  // make sure each eigenvector is normalized
  // if (Nel[1]){
  //   for (size_t Iobj=0; Iobj&lt;Nobj; ++Iobj){
  //     offset = Iobj*span + Nel[0];
  //     auto normI = std::sqrt(inner_product(Nel[1], sink_j+offset, sink_j+offset));
  //     for (size_t Jeig=0; Jeig&lt;Nel[1]; ++Jeig) sink_j[offset+Jeig] /= normI;
  //   }
  // }
}

template&lt;class T, class R, class I, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt; std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value &amp;&amp; !std::is_base_of&lt;LatVec,A&lt;T&gt;&gt;::value&gt;::type,
         class S = typename std::common_type&lt;T,R&gt;::type
         &gt;
void new_unsafe_interpolate_to(const A&lt;T&gt;&amp; source,
                           const std::array&lt;I, 4&gt;&amp; nEl,
                           const size_t nObj,
                           const std::vector&lt;size_t&gt;&amp; iSrc,
                           const std::vector&lt;R&gt;&amp; weights,
                           A&lt;S&gt;&amp; sink,
                           const size_t iSnk)
{
  info_update(&quot;The function unsafe_interpolate_to should not be used any longer. Please move to the new InterpolationData class&quot;);
  S *sink_i = sink.data(iSnk);
  T *source_0 = source.data(iSrc[0]);
  size_t offset, span = static_cast&lt;size_t&gt;(nEl[0])+static_cast&lt;size_t&gt;(nEl[1])+static_cast&lt;size_t&gt;(nEl[2]);
  T e_i_theta;
  for (size_t x=0; x&lt;iSrc.size(); ++x){
    T *source_i = source.data(iSrc[x]);
    // loop over the objects (modes)
    for (size_t iObj=0; iObj&lt;nObj; ++iObj){
      // find the weighted sum of each scalar
      for (size_t iSc=0; iSc &lt; nEl[0]; ++iSc)
        sink_i[iObj*span + iSc] += weights[x]*source_i[iObj*span + iSc];
      if (nEl[1]){
        // eigenvectors require special treatment since they can have an arbitrary phase difference
        offset = iObj*span + nEl[0];
        // find the arbitrary phase eⁱᶿ between different-object eigenvectors
        e_i_theta = antiphase(hermitian_product(nEl[1], source_0+offset, source_i+offset));
        // remove the arbitrary phase while adding the weighted value
        for (size_t iEv=0; iEv&lt;nEl[1]; ++iEv)
          sink_i[offset+iEv] += weights[x]*(e_i_theta*source_i[offset+iEv]);
      }
      // vector and matrix elements are treated as scalars
      for (size_t iVM=nEl[0]+nEl[1]; iVM&lt;span; ++iVM)
        sink_i[iObj*span + iVM] += weights[x]*source_i[iObj*span + iVM];
    }
  }
  // ensure the eigenvectors are still normalized
  // if (nEl[1]){
  //   for (size_t iObj=0; iObj&lt;nObj; ++iObj){
  //     offset = iObj*span + nEl[0];
  //     auto normI = std::sqrt(inner_product(nEl[1], sink_i+offset, sink_i+offset));
  //     for (size_t iEv=0; iEv&lt;nEl[1]; ++iEv) sink_i[offset+iEv]/=normI;
  //   }
  // }
}

template&lt;class T&gt; void ArrayVector&lt;T&gt;::permute(const std::vector&lt;size_t&gt;&amp; p){
  debug_exec(std::string msg;)
  std::vector&lt;size_t&gt; s=p, o(this-&gt;size());
  std::iota(o.begin(), o.end(), 0u);
  std::sort(s.begin(), s.end());
  debug_exec(\
    if (!std::includes(o.begin(), o.end(), s.begin(), s.end()) || p.size()!=this-&gt;size()){\
      msg = &quot;The provided permutation vector [&quot;;\
      for (auto x: p) msg += &quot; &quot; + std::to_string(x);\
      msg += &quot; ] is invalid&quot;;\
      msg += &quot; A permutation of [&quot;;\
      for (auto x: o) msg += &quot; &quot; + std::to_string(x);\
      msg += &quot; ] was expected.&quot;;\
    }\
  )
  // get the inverse permutation so we can swap elements
  for (size_t i=0; i&lt;p.size(); ++i) s[p[i]] = i;
  // Now perform all swapping of Arrays until everything is in order
  ArrayVector&lt;T&gt; store(this-&gt;numel(), 1u);
  for (size_t i=0; i&lt;this-&gt;size();){
    if (s[i]!=i){
      store.set(0, this-&gt;extract(i));
      this-&gt;set(i, this-&gt;extract(s[i]));
      this-&gt;set(s[i], store);
      std::swap(s[i], s[s[i]]);
    } else
      ++i;
  }
  // if debugging, confirm that the permutation worked
  debug_exec(\
    if (!std::is_sorted(s.begin(), s.end())){\
      msg = &quot;Undoing the permutation [&quot;;\
      for (auto x: p) msg += &quot; &quot; + std::to_string(x);\
      msg += &quot; ] failed. End result is [&quot;;\
      for (auto x: s) msg += &quot; &quot; + std::to_string(x);\
      msg += &quot; ]&quot;;\
    }\
  )
}

template&lt;class T&gt; bool ArrayVector&lt;T&gt;::swap(const size_t i, const size_t j){
  if (i&lt;this-&gt;size() &amp;&amp; j&lt;this-&gt;size()){
    ArrayVector&lt;T&gt; store(this-&gt;numel(), 1u);
    store.set(0, this-&gt;extract(i));
    this-&gt;set(i, this-&gt;extract(j));
    this-&gt;set(j, store);
    return true;
  }
  return false;
}
template&lt;class T&gt; bool ArrayVector&lt;T&gt;::swap(const size_t i, const size_t a, const size_t b){
  if (i&lt;this-&gt;size() &amp;&amp; a&lt;this-&gt;numel() &amp;&amp; b&lt;this-&gt;numel()){
    T tmp = this-&gt;getvalue(i,a);
    this-&gt;insert(this-&gt;getvalue(i,b), i,a);
    this-&gt;insert(tmp, i,b);
    return true;
  }
  return false;
}

// template&lt;class T&gt; std::vector&lt;size_t&gt; ArrayVector&lt;T&gt;::find(void) const {
//   if (this-&gt;size() != 1u || this-&gt;numel() != 1u)
//     throw std::logic_error(&quot;Find only makes sense for ArrayScalar or ScalarVector inputs&quot;);
//   std::vector&lt;size_t&gt; out;
//   for (size_t i=0; i&lt;this-&gt;size(); ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j)
//   if (this-&gt;getvalue(i,j)) out.push_back(i+j); // either i or j is zero.
//   return out;
// }
template&lt;class T, template&lt;class&gt; class A,
         typename=typename std::enable_if&lt; std::is_base_of&lt;ArrayVector&lt;T&gt;,A&lt;T&gt;&gt;::value &amp;&amp; !std::is_base_of&lt;LatVec,A&lt;T&gt;&gt;::value&gt;::type
         &gt;
std::vector&lt;size_t&gt; find(const A&lt;T&gt;&amp; a){
  if (a.size() != 1u &amp;&amp; a.numel() != 1u)
    throw std::logic_error(&quot;Find only makes sense for ArrayScalar or ScalarVector inputs&quot;);
  std::vector&lt;size_t&gt; out;
  for (size_t i=0; i&lt;a.size(); ++i) for (size_t j=0; j&lt;a.numel(); ++j)
  if (a.getvalue(i,j)) out.push_back(i+j); // either i or j is zero.
  return out;
}

template&lt;class T&gt; std::vector&lt;T&gt; ArrayVector&lt;T&gt;::to_std() const {
  if (this-&gt;size() != 1u &amp;&amp; this-&gt;numel() != 1u)
    throw std::logic_error(&quot;to_std only supports ArrayScalar or ScalarVector inputs&quot;);
  std::vector&lt;T&gt; out;
  for (size_t i=0; i&lt;this-&gt;size(); ++i) for (size_t j=0; j&lt;this-&gt;numel(); ++j)
  out.push_back(this-&gt;getvalue(i,j));
  return out;
}
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Gregory Tucker

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>