

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File lattice.hpp &mdash; brille  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        <script src="../_static/katex_autorenderer.js"></script>
        <script src="../_static/collapsible-lists\js\CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists\js\apply-collapsible-lists.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/katex-math.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists\css\tree_view.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> brille
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User documents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install_guide.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../motivation.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_usage.html">Memory Use</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">User Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">API documents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../brille.html">Python module <code class="docutils literal notranslate"><span class="pre">brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../brille.html#pybind11-module-brille">pybind11 module <code class="docutils literal notranslate"><span class="pre">_brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../plotting.html">Plotting utilities for <code class="docutils literal notranslate"><span class="pre">brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">C++ Library API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">brille</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Program Listing for File lattice.hpp</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_src_lattice.hpp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-lattice-hpp">
<span id="program-listing-file-src-lattice-hpp"></span><h1>Program Listing for File lattice.hpp<a class="headerlink" href="#program-listing-for-file-lattice-hpp" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_src_lattice.hpp.html#file-src-lattice-hpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src\lattice.hpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>/* Copyright 2019 Greg Tucker
//
// This file is part of brille.
//
// brille is free software: you can redistribute it and/or modify it under the
// terms of the GNU Affero General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
//
// brille is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with brille. If not, see &lt;https://www.gnu.org/licenses/&gt;.            */

#ifndef _LATTICE_CLASS_H_
#define _LATTICE_CLASS_H_

#include &lt;assert.h&gt;
#include &lt;vector&gt;
// #include &quot;utilities.hpp&quot;
#include &quot;primitive.hpp&quot;
#include &quot;basis.hpp&quot;


// forward declare the two types of lattices so that they can be mutually-referential
class Lattice;
class Direct;
class Reciprocal;

enum class AngleUnit { not_provided, radian, degree, pi };

template&lt;class T, class I&gt; void latmat_to_lenang(const T* latmat, const I c, const I r, T* len, T* ang){
  T n[9];
  // compute the dot product of each row with itself
  for (int i=0; i&lt;3; ++i)  for (int j=0; j&lt;3; ++j)  len[i] += latmat[i*c+j*r]*latmat[i*c+j*r];
  // the lattice vector lengths are the square root of this
  for (int i=0; i&lt;3; ++i) len[i] = std::sqrt(len[i]);
  // normalize the row vectors, leaving only angle information
  for (int i=0; i&lt;3; ++i) for (int j=0; j&lt;3; ++j) n[i*c+j*r] = latmat[i*c+j*r]/len[i];
  // take the dot product between cyclically permuted rows: 0=1⋅2, 1=2⋅0, 2=0⋅1
  for (int i=0; i&lt;3; ++i) for (int j=0; j&lt;3; ++j)  ang[i] += n[c*((i+1)%3)+j*r]*n[c*((i+2)%3)+j*r];
  // the lattice angles are the arccosines of these dot products of normalized lattice vectors
  for (int i=0; i&lt;3; ++i) ang[i] = std::acos(ang[i]);
}

class Lattice{
protected:
  std::array&lt;double,3&gt; len;
  std::array&lt;double,3&gt; ang;
  double volume;
  Spacegroup spg;
  Symmetry spgsym;
  Pointgroup ptg;
  PointSymmetry ptgsym;
  Basis basis;
protected:
  double unitvolume() const;
  Lattice inner_star() const;
  template&lt;class I&gt;
  void set_len_pointer(const double *lvec, const I span){
    for (int i=0;i&lt;3;i++) this-&gt;len[i] = lvec[i*span];
  }
  template&lt;class I&gt;
  void set_ang_pointer(const double *avec, const I span, const AngleUnit angle_unit){
    AngleUnit au = angle_unit;
    if (au == AngleUnit::not_provided){
      double minang = (std::numeric_limits&lt;double&gt;::max)();
      double maxang = (std::numeric_limits&lt;double&gt;::lowest)();
      for (int i=0; i&lt;3; ++i){
        if (avec[i*span] &lt; minang) minang = avec[i*span];
        if (avec[i*span] &gt; maxang) maxang = avec[i*span];
      }
      if (minang &lt; 0.) throw std::runtime_error(&quot;Unexpected negative inter-facial cell angle&quot;);
      // 1 is not a good separator between π-radian and radian, since 1 radian ≈ 57.3°
      // au = (maxang &lt; 1.0) ? AngleUnit::pi : (maxang &lt; 2.0*PIOVERTWO) ? AngleUnit::radian : AngleUnit::degree;
      au = (maxang &lt; 2.0*PIOVERTWO) ? AngleUnit::radian : AngleUnit::degree;
    }
    double conversion = (AngleUnit::radian == au) ? 1.0 : PIOVERTWO*((AngleUnit::degree == au) ? 1.0/90.0 : 2.0);
    for (int i=0;i&lt;3;i++) this-&gt;ang[i] = avec[i*span]*conversion;
  }
  // void set_len_scalars(const double, const double, const double);
  // void set_ang_scalars(const double, const double, const double, const AngleUnit);
  void check_ang(const AngleUnit);
  void check_hall_number(const int h);
  void check_IT_name(const std::string&amp; itname, const std::string&amp; choice=&quot;&quot;);
public:
  Lattice(const double *, const int h=1);
  template&lt;class I&gt;//, typename=typename std::enable_if&lt;std::is_integral&lt;I&gt;::value&gt;::type&gt;
  Lattice(const double * latmat, std::vector&lt;I&gt;&amp; strides, const int h){
    double l[3]={0,0,0}, a[3]={0,0,0};
    latmat_to_lenang(latmat,strides[0]/sizeof(double),strides[1]/sizeof(double),l,a);
    this-&gt;set_len_pointer(l,1);
    this-&gt;set_ang_pointer(a,1, AngleUnit::radian);
    this-&gt;volume=this-&gt;calculatevolume();
    this-&gt;check_hall_number(h);
  }
  template&lt;class I&gt;//, typename=typename std::enable_if&lt;std::is_integral&lt;I&gt;::value&gt;::type&gt;
  Lattice(const double * lengths, std::vector&lt;I&gt;&amp; lenstrides, const double * angles, std::vector&lt;I&gt;&amp; angstrides, const int h, const AngleUnit au=AngleUnit::not_provided){
    this-&gt;set_len_pointer(lengths,lenstrides[0]/sizeof(double));
    this-&gt;set_ang_pointer(angles,angstrides[0]/sizeof(double), au);
    this-&gt;volume=this-&gt;calculatevolume();
    this-&gt;check_hall_number(h);
  }
  Lattice(const double *, const double *, const int h=1, const AngleUnit au=AngleUnit::not_provided);
  Lattice(const double la=1.0, const double lb=1.0, const double lc=1.0, const double al=PIOVERTWO, const double bl=PIOVERTWO, const double cl=PIOVERTWO, const int h=1);
  Lattice(const double *, const std::string&amp;, const std::string&amp; choice=&quot;&quot;);
  Lattice(const double *, const double *, const std::string&amp;, const std::string&amp; choice=&quot;&quot;, const AngleUnit au=AngleUnit::not_provided);
  template&lt;class I&gt;//, typename=typename std::enable_if&lt;std::is_integral&lt;I&gt;::value&gt;::type&gt;
  Lattice(const double * latmat, std::vector&lt;I&gt;&amp; strides, const std::string&amp; itname, const std::string&amp; choice=&quot;&quot;){
    double l[3]={0,0,0}, a[3]={0,0,0};
    latmat_to_lenang(latmat,strides[0]/sizeof(double),strides[1]/sizeof(double),l,a);
    this-&gt;set_len_pointer(l,1);
    this-&gt;set_ang_pointer(a,1, AngleUnit::radian);
    this-&gt;volume=this-&gt;calculatevolume();
    this-&gt;check_IT_name(itname, choice);
  }
  template&lt;class I&gt;//, typename=typename std::enable_if&lt;std::is_integral&lt;I&gt;::value&gt;::type&gt;
  Lattice(const double * lengths, std::vector&lt;I&gt;&amp; lenstrides, const double * angles, std::vector&lt;I&gt;&amp; angstrides, const std::string&amp; itname, const std::string&amp; choice=&quot;&quot;, const AngleUnit au=AngleUnit::not_provided){
    this-&gt;set_len_pointer(lengths,lenstrides[0]/sizeof(double));
    this-&gt;set_ang_pointer(angles,angstrides[0]/sizeof(double), au);
    this-&gt;volume=this-&gt;calculatevolume();
    this-&gt;check_IT_name(itname, choice);
  }
  Lattice(const double, const double, const double, const double, const double, const double, const std::string&amp;, const std::string&amp; choice=&quot;&quot;);
  virtual ~Lattice() = default;
  double get_a     () const {return len[0];}
  double get_b     () const {return len[1];}
  double get_c     () const {return len[2];}
  double get_alpha () const {return ang[0];}
  double get_beta  () const {return ang[1];}
  double get_gamma () const {return ang[2];}
  double get_volume() const {return volume;}
  double calculatevolume();
  void get_metric_tensor(double * mt) const ;
  void get_covariant_metric_tensor(double *mt) const ;
  void get_contravariant_metric_tensor(double *mt) const ;
  // some functions don&#39;t logically make sense for this base class, but
  // do for the derived classes. define them here for funsies
  bool issame(const Lattice&amp;) const; // this should really have a tolerance
  bool isapprox(const Lattice&amp;) const;
  int ispermutation(const Lattice&amp;) const;
  virtual void print();
  virtual std::string string_repr();
  int get_hall() const {return spg.get_hall_number();}
  int set_hall(const int h) { check_hall_number(h); return get_hall(); }
  Spacegroup get_spacegroup_object() const { return spg; }
  Pointgroup get_pointgroup_object() const { return ptg; }
  Symmetry get_spacegroup_symmetry(const int time_reversal=0) const {
    if (time_reversal &amp;&amp; !spgsym.has_space_inversion()){
      Symmetry gens = spgsym.generators();
      Motion&lt;int,double&gt; space_inversion({{-1,0,0, 0,-1,0, 0,0,-1}},{{0.,0.,0.}});
      gens.add(space_inversion);
      return gens.generate();
    }
    return spgsym;
  }
  PointSymmetry get_pointgroup_symmetry(const int time_reversal=0) const {
    if (time_reversal &amp;&amp; !ptgsym.has_space_inversion()){
      // time_reversal == space_inversion. requested but not present
      // get the generators of the pointgroup
      PointSymmetry gens = ptgsym.generators();
      // add time-reversal/space-inversion
      std::array&lt;int,9&gt; trsi{{-1,0,0, 0,-1,0, 0,0,-1}};
      gens.add(trsi);
      // generate the new pointgroup
      return gens.generate();
    } else {
      return ptgsym;
    }
  }
  bool has_space_inversion() const { return ptgsym.has_space_inversion(); }
  Basis get_basis() const {return basis; }
  //template &lt;class R, class II&gt;
  Basis set_basis(const std::vector&lt;std::array&lt;double,3&gt;&gt;&amp; pos, const std::vector&lt;unsigned long&gt;&amp; typ) {
    this-&gt;basis = Basis(pos, typ);
    return this-&gt;get_basis();
  }
  Basis set_basis(const Basis&amp; b) {
    this-&gt;basis = b;
    return this-&gt;get_basis();
  }
};

class Direct: public Lattice{
public:
  template&lt;class ...Types&gt; Direct(Types ... args): Lattice(args...){}
  Direct(const Lattice&amp; lat): Lattice(lat){}
  Reciprocal star() const;
  void get_xyz_transform(double*) const;
  void get_xyz_transform(double*, const size_t, const size_t) const;
  template&lt;class I&gt; void get_xyz_transform(double*, std::vector&lt;I&gt;&amp;) const;
  void get_inverse_xyz_transform(double*) const;
  void get_inverse_xyz_transform(double*, const size_t, const size_t) const;
  template&lt;class I&gt; void get_inverse_xyz_transform(double*, std::vector&lt;I&gt;&amp;) const;
  void get_lattice_matrix(double*) const;
  void get_lattice_matrix(double*, const size_t, const size_t) const;
  template&lt;class I&gt; void get_lattice_matrix(double*, std::vector&lt;I&gt;&amp;) const;
  bool isstar(const Direct&amp;) const;
  bool isstar(const Reciprocal&amp;) const;
  void print() override;
  std::string string_repr() override;
  Direct primitive(void) const;
};
class Reciprocal: public Lattice{
public:
  template&lt;class ...Types&gt; Reciprocal(Types ... args): Lattice(args...){}
  Reciprocal(const Lattice&amp; lat): Lattice(lat){}
  Direct star() const;
  void get_B_matrix(double*) const;
  void get_B_matrix(double*, const size_t, const size_t) const;
  template&lt;class I&gt; void get_B_matrix(double*, std::vector&lt;I&gt;&amp;) const;
  void get_xyz_transform(double*) const;
  void get_xyz_transform(double*, const size_t, const size_t) const;
  template&lt;class I&gt; void get_xyz_transform(double*, std::vector&lt;I&gt;&amp;) const;
  void get_inverse_xyz_transform(double*) const;
  void get_inverse_xyz_transform(double*, const size_t, const size_t) const;
  template&lt;class I&gt; void get_inverse_xyz_transform(double*, std::vector&lt;I&gt;&amp;) const;
  void get_lattice_matrix(double*) const;
  void get_lattice_matrix(double*, const size_t, const size_t) const;
  template&lt;class I&gt; void get_lattice_matrix(double*, std::vector&lt;I&gt;&amp;) const;
  bool isstar(const Reciprocal&amp;) const;
  bool isstar(const Direct&amp;) const;
  void print() override;
  std::string string_repr() override;
  Reciprocal primitive(void) const;
};

template &lt;typename T&gt; struct LatticeTraits{
  using type = void;
  using star = void;
};
#ifndef DOXYGEN_SHOULD_SKIP_THIS
template&lt;&gt; struct LatticeTraits&lt;Direct&gt;{
  using type = Direct;
  using star = Reciprocal;
};
template&lt;&gt; struct LatticeTraits&lt;Reciprocal&gt;{
  using type = Reciprocal;
  using star = Direct;
};
#endif

#endif
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Gregory Tucker

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>