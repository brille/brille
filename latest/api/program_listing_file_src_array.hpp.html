

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Program Listing for File array.hpp &mdash; brille  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/katex-math.css" type="text/css" />
  <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        <script src="../_static/katex_autorenderer.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> brille
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User documents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install_guide.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../motivation.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_usage.html">Memory Use</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">User Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">API documents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../brille.html">Python module <code class="docutils literal notranslate"><span class="pre">brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../brille.html#pybind11-module-brille-brille">pybind11 module <code class="docutils literal notranslate"><span class="pre">brille._brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../plotting.html">Plotting utilities for <code class="docutils literal notranslate"><span class="pre">brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="library_root.html">C++ Library API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">brille</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Program Listing for File array.hpp</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/api/program_listing_file_src_array.hpp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="program-listing-for-file-array-hpp">
<span id="program-listing-file-src-array-hpp"></span><h1>Program Listing for File array.hpp<a class="headerlink" href="#program-listing-for-file-array-hpp" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file_src_array.hpp.html#file-src-array-hpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">src/array.hpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>#ifndef ARRAY_HPP
#define ARRAY_HPP

#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
#include &lt;array&gt;
#include &lt;math.h&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

#include &quot;subscript.hpp&quot;
#include &quot;utilities.hpp&quot;
#include &quot;comparisons.hpp&quot;
#include &quot;approx.hpp&quot;
#include &quot;types.hpp&quot;
#include &quot;array_.hpp&quot;
#include &quot;array2.hpp&quot;

namespace brille {
template&lt;class T&gt; class Array{
public:
  using ref_t = std::shared_ptr&lt;void&gt;;
  using shape_t = brille::shape_t;
  using bItr = BroadcastIt&lt;ind_t&gt;;
  using sItr = SubIt&lt;ind_t&gt;;
  using aItr = ArrayIt&lt;T&gt;;
protected:
  T*    _data;
  ind_t _num;
  ind_t _shift;
  bool  _own;
  ref_t _ref;
  bool  _mutable;
  // shape_t _offset; //! A multidimensional offset different from {0,…,0} if a view
  shape_t _shape;
  shape_t _stride;
public:
  // accessors
  T* data() {return _data;}
  T* data(const ind_t&amp; idx){ return _data + this-&gt;l2l_d(idx);}
  T* data(const shape_t&amp; idx){ return _data + this-&gt;s2l_d(idx);}
  const T* data() const {return _data;}
  const T* data(const ind_t&amp; idx) const {return _data + this-&gt;l2l_d(idx);}
  const T* data(const shape_t&amp; idx) const {return _data + this-&gt;s2l_d(idx);}
  ind_t raw_size() const {return _num;}
  ind_t raw_shift() const {return _shift;}
  bool own() const {return _own;}
  ref_t ref() const {return _ref;}
  bool  ismutable(void) const {return _mutable;}
  bool  isconst(void) const {return !_mutable;}
  ind_t ndim(void) const {return _shape.size();}
  ind_t numel(void) const {
    auto nel = std::accumulate(_shape.begin(), _shape.end(), 1, std::multiplies&lt;&gt;());
    return this-&gt;ndim() ? static_cast&lt;ind_t&gt;(nel) : 0u;
  }
  // shape_t offset(void) const {return _offset;}
  ind_t size(const ind_t dim) const {
    assert(dim &lt; _shape.size());
    return _shape[dim];
  }
  shape_t shape(void) const {return _shape;}
  shape_t stride(void) const {return _stride;}
  shape_t cstride() const {
    shape_t cs(_stride);
    for (auto&amp; s: cs) s *= sizeof(T);
    return cs;
  }
  sItr subItr() const { return sItr(_shape); }
  sItr subItr(const shape_t&amp; fix) const { return sItr(_shape, fix); }
  aItr valItr() const { return aItr(*this); }
  bItr broadcastItr(const shape_t&amp; other) const { return bItr(_shape, other); }
  template&lt;class R&gt;
  bItr broadcastItr(const Array&lt;R&gt;&amp; other) const {return bItr(_shape, other.shape());}
  bool is_column_ordered() const { // stride {1,2,4,8} is column ordered
    //return std::is_sorted(_stride.begin(), _stride.end(), [](ind_t a, ind_t b){return a &lt;= b;});
    for (size_t i=1; i&lt;_stride.size(); ++i) if (_stride[i] &lt; _stride[i-1]) return false;
    return true;
  }
  bool is_row_ordered() const { // stride {8,4,2,1} is row ordered
    // is_sorted doesn&#39;t like the vector {1,1} with this predicate?!
    //return std::is_sorted(_stride.begin(), _stride.end(), [](ind_t a, ind_t b){return a &gt;= b;});
    for (size_t i=1; i&lt;_stride.size(); ++i) if (_stride[i] &gt; _stride[i-1]) return false;
    return true;
  }
  bool is_contiguous() const {
    shape_t expected(1, 1);
    if (this-&gt;is_row_ordered()){
      for (auto s = _shape.rbegin(); s!=_shape.rend(); ++s)
        expected.push_back(expected.back()*(*s));
      expected.pop_back();
      return std::equal(_stride.begin(), _stride.end(), expected.rbegin());
    }
    if (this-&gt;is_column_ordered()){
      for (auto s : _shape) expected.push_back(expected.back()*s);
      // expected has one too many elements
      return std::equal(_stride.begin(), _stride.end(), expected.begin());
    }
    return false;
  }
  // empty initializer
  explicit Array()
  // : _data(nullptr), _num(0), _own(false), _ref(std::make_shared&lt;char&gt;()),
  // _mutable(false), _offset({0}), _shape({0}), _stride({1})
  : _data(nullptr), _num(0), _shift(0), _own(false), _ref(std::make_shared&lt;char&gt;()),
  _mutable(false), _shape({0}), _stride({1})
  {}
  // 1D initializer
  Array(T* data, const ind_t num, const bool own, const bool mut=true)
  // : _data(data), _num(num), _own(own), _ref(std::make_shared&lt;char&gt;()),
  //   _mutable(mut), _offset({0}), _shape({num}), _stride({1})
  : _data(data), _num(num), _shift(0u), _own(own), _ref(std::make_shared&lt;char&gt;()),
    _mutable(mut), _shape({num}), _stride({1})
  {
    this-&gt;init_check();
  }
  // ND initializer
  Array(T* data, const ind_t num, const bool own,
    const shape_t&amp; shape, const shape_t&amp; stride, const bool mut=true)
  // : _data(data), _num(num), _own(own), _ref(std::make_shared&lt;char&gt;()),
  //   _mutable(mut), _offset(shape.size(),0), _shape(shape), _stride(stride)
  : _data(data), _num(num), _shift(0u), _own(own), _ref(std::make_shared&lt;char&gt;()),
    _mutable(mut), _shape(shape), _stride(stride)
  {
    this-&gt;init_check();
  }
  // ND initializer with reference-counter specified (used in pybind11 wrapper)
  template&lt;class P&gt;
  Array(T* data, const ind_t num, const bool own, std::shared_ptr&lt;P&gt; ref,
    const shape_t&amp; shape, const shape_t&amp; stride, const bool mut=true)
  // : _data(data), _num(num), _own(own), _ref(ref),
  //   _mutable(mut), _offset(shape.size(),0), _shape(shape), _stride(stride)
  : _data(data), _num(num), _shift(0u), _own(own), _ref(ref),
    _mutable(mut), _shape(shape), _stride(stride)
  {
    this-&gt;init_check();
  }
  // ND view constructor
  // Array(T* data, const ind_t num, const bool own, const ref_t&amp; ref,
  //   const shape_t&amp; offset, const shape_t&amp; shape, const shape_t&amp; stride, const bool mut=true)
  // : _data(data), _num(num), _own(own), _ref(ref), _mutable(mut), _offset(offset),
  //   _shape(shape), _stride(stride)
  template&lt;class P&gt;
  Array(T* data, const ind_t num, const ind_t shift, const bool own, const std::shared_ptr&lt;P&gt;&amp; ref,
    const shape_t&amp; shape, const shape_t&amp; stride, const bool mut=true)
  : _data(data), _num(num), _shift(shift), _own(own), _ref(ref), _mutable(mut),
    _shape(shape), _stride(stride)
  {
    this-&gt;init_check();
  }
  // 2D allocate new memory constructor
  Array(const ind_t s0, const ind_t s1)
  // : _mutable(true), _offset({0,0}), _shape({s0,s1}), _stride({s1,1})
  : _shift(0u), _mutable(true), _shape({s0,s1}), _stride({s1,1})
  {
    this-&gt;construct();
    this-&gt;init_check();
  }
  // 2D initialize new memory constructor
  Array(const ind_t s0, const ind_t s1, const T init)
  // : _mutable(true), _offset({0,0}), _shape({s0,s1}), _stride({s1,1})
  : _shift(0u), _mutable(true), _shape({s0,s1}), _stride({s1,1})
  {
    this-&gt;construct(init);
    this-&gt;init_check();
  }
  // ND allocate new memory constructor
  Array(const shape_t&amp; shape)
  // : _mutable(true), _offset(shape.size(), 0), _shape(shape)
  : _shift(0u), _mutable(true), _shape(shape)
  {
    this-&gt;set_stride();
    this-&gt;construct();
    this-&gt;init_check();
  }
  // ND initialize new memory constructor
  Array(const shape_t&amp; shape, const T init)
  // : _mutable(true), _offset(shape.size(), 0), _shape(shape)
  : _shift(0u), _mutable(true), _shape(shape)
  {
    this-&gt;set_stride();
    this-&gt;construct(init);
    this-&gt;init_check();
  }
  // ND allocate new memory with specified stride constructor
  Array(const shape_t&amp; shape, const shape_t&amp; stride)
  // : _mutable(true), _offset(shape.size(), 0), _shape(shape), _stride(stride)
  : _shift(0u), _mutable(true), _shape(shape), _stride(stride)
  {
    this-&gt;construct();
    this-&gt;init_check();
  }
  // ND initialize new memory with specified stride constructor
  Array(const shape_t&amp; shape, const shape_t&amp; stride, const T init)
  // : _mutable(true), _offset(shape.size(), 0), _shape(shape), _stride(stride)
  : _shift(0u), _mutable(true), _shape(shape), _stride(stride)
  {
    this-&gt;construct(init);
    this-&gt;init_check();
  }
  // otherwise possibly ambiguous constructor from std::vector
  static Array&lt;T&gt; from_std(const std::vector&lt;T&gt;&amp; data){
    ind_t num = static_cast&lt;ind_t&gt;(data.size());
    T* d = new T[num]();
    for (ind_t i=0; i&lt;num; ++i) d[i] = data[i];
    // take ownership of d while creating the Array
    return Array&lt;T&gt;(d, num, true);
  }
  template&lt;class R, size_t Nel&gt;
  static Array&lt;T&gt; from_std(const std::vector&lt;std::array&lt;R,Nel&gt;&gt;&amp; data){
    shape_t shape{static_cast&lt;ind_t&gt;(data.size()), static_cast&lt;ind_t&gt;(Nel)};
    shape_t stride{shape[1], 1};
    ind_t num = shape[0]*shape[1];
    T* d = new T[num]();
    ind_t x{0};
    for (ind_t i=0; i&lt;shape[0]; ++i) for (ind_t j=0; j&lt;shape[1]; ++j)
      d[x++] = static_cast&lt;T&gt;(data[i][j]);
    return Array&lt;T&gt;(d, num, true, shape, stride);
  }
  // Construct an Array from an Array2 and higher-dimensional shape:
  Array(const Array2&lt;T&gt;&amp; twod, const shape_t&amp; shape): _shape(shape){
    this-&gt;set_stride();
    Array2&lt;T&gt; c2d = twod.contiguous_row_ordered_copy();
    _data    = c2d.data();
    _num     = c2d.raw_size();
    _shift   = c2d.raw_shift();
    _own     = c2d.own();
    _ref     = c2d.ref();
    _mutable = c2d.ismutable();
    this-&gt;init_check();
  }

  // Rule-of-five definitions since we may not own the associated raw array:
  Array(const Array&lt;T&gt;&amp; o)
  // : _data(o._data), _num(o._num), _own(o._own), _ref(o._ref),
  //   _mutable(o._mutable), _offset(o._offset), _shape(o._shape), _stride(o._stride)
  : _data(o._data), _num(o._num), _shift(o._shift), _own(o._own), _ref(o._ref),
    _mutable(o._mutable), _shape(o._shape), _stride(o._stride)
  {}
  ~Array(){
    if (_own &amp;&amp; _ref.use_count()==1 &amp;&amp; _data != nullptr) delete[] _data;
  }
  Array&lt;T&gt;&amp; operator=(const Array&lt;T&gt;&amp; other){
    if (this != &amp;other){
      if (_own){
        T* old_data = _data;
        ref_t old_ref = _ref;
        _data = other._data;
        _ref = other._ref;
        if (old_ref.use_count()==1 &amp;&amp; old_data != nullptr) delete[] old_data;
      } else {
        _data = other._data;
        _ref = other._ref;
      }
      _own = other.own();
      _num = other.raw_size();
      _shift = other.raw_shift();
      _mutable = other.ismutable();
      // _offset = other.offset();
      _shape = other.shape();
      _stride = other.stride();
    }
    return *this;
  }


  // type casting requires a copy
  // the reference pointer type does not need to be P since a new raw array is made
  // handles also Array&lt;T&gt;(Array&lt;T&gt;&amp;) reference type conversion
  template&lt;class R&gt;
  Array(const Array&lt;R&gt;&amp; other)
  // : _mutable(true), _offset(other.ndim(),0), _shape(other.shape())
  : _shift(0u), _mutable(true), _shape(other.shape())
  {
    this-&gt;set_stride();
    this-&gt;construct();
    for (auto x: SubIt(_shape)) _data[s2l_d(x)] = static_cast&lt;T&gt;(other[x]);
  }
  template&lt;class R&gt;
  Array&lt;T&gt;&amp; operator=(const Array&lt;R&gt;&amp; other){
    _mutable = true;
    _shape = other.shape();
    // _offset = shape_t(_shape.size(), 0);
    _shift = 0u;
    this-&gt;set_stride();
    this-&gt;construct();
    for (auto x: SubIt(_shape)) _data[s2l_d(x)] = static_cast&lt;T&gt;(other[x]);
    return *this;
  }

  // modifiers
  bool make_mutable() {_mutable = true; return _mutable;}
  bool make_immutable() {_mutable = false; return _mutable;}
  Array&lt;T&gt; decouple() const {
    if (!_own || !_mutable || _ref.use_count() &gt; 1) return this-&gt;_decouple();
    return *this;
  }

  // data accessors
        T&amp; operator[](ind_t    lin)       {return _data[this-&gt;l2l_d(lin)];}
  const T&amp; operator[](ind_t    lin) const {return _data[this-&gt;l2l_d(lin)];}

        T&amp; operator[](shape_t&amp; sub)       {return _data[this-&gt;s2l_d(sub)];}
  const T&amp; operator[](shape_t&amp; sub) const {return _data[this-&gt;s2l_d(sub)];}
protected: // so inherited classes can calculate subscript indexes into their data
  // ind_t l2l_d(const ind_t l) const {
  //   shape_t sub = lin2sub(l, _stride);
  //   return offset_sub2lin(_offset, sub, _stride);
  // }
  // ind_t s2l_d(const shape_t&amp; s) const {
  //   assert(s.size() == _offset.size());
  //   return offset_sub2lin(_offset, s, _stride);
  // }
  ind_t l2l_d(const ind_t l) const {
    return l + _shift;
  }
  ind_t s2l_d(const shape_t&amp; s) const {
    return sub2lin(s, _stride) + _shift;
  }
private:
  ind_t size_from_shape(const shape_t&amp; s) const {
    // std::reduce can perform the same operation in parallel, but isn&#39;t implemented
    // in the gcc libraries until v9.3. Since the number of dimensions is (probably)
    // small a serial algorithm is not a giant speed hit.
    size_t sz = std::accumulate(s.begin(), s.end(), ind_t(1), std::multiplies&lt;ind_t&gt;());
    return static_cast&lt;ind_t&gt;(sz);
  }
  ind_t size_from_shape() const {return this-&gt;size_from_shape(_shape);}
  void construct() {
    _num = this-&gt;size_from_shape();
    if (_num &gt; 0){
      _ref = std::make_shared&lt;char&gt;();
      _data = new T[_num]();
      _own = true;
    } else {
      _data = nullptr;
      _own = false;
    }
  }
  void construct(const T init){
    this-&gt;construct();
    if (_num &gt; 0 &amp;&amp; _data != nullptr) std::fill(_data, _data+_num, init);
  }
  void set_stride(void){
    _stride.clear();
    _stride.push_back(1);
    for (auto s = _shape.rbegin(); s!=_shape.rend(); ++s)
      _stride.push_back(_stride.back()*(*s));
    _stride.pop_back();
    std::reverse(_stride.begin(), _stride.end());
  }
  void init_check(void){
    // if (_shape.size() != _offset.size() || _shape.size() != _stride.size())
    if (_shape.size() != _stride.size())
    throw std::runtime_error(&quot;Attempting to construct Array with inconsistent offset, shape, and strides&quot;);
    // shape_t sh;
    // for (size_t i=0; i&lt;_shape.size(); ++i) sh.push_back(_offset[i]+_shape[i]);
    // ind_t offset_size = this-&gt;size_from_shape(sh);
    ind_t offset_size = _shift + this-&gt;size_from_shape(_shape);
    if (_num &lt; offset_size) {
      // std::string msg = &quot;The offset { &quot;;
      // for (auto x: _offset) msg += std::to_string(x) + &quot; &quot;;
      std::string msg = &quot;The shift {&quot; + std::to_string(_shift);
      msg += &quot;} and size { &quot;;
      for (auto x: _shape) msg += std::to_string(x) + &quot; &quot;;
      msg += &quot;} of an Array must not exceed the allocated pointer size &quot;;
      msg += std::to_string(_num);
      throw std::runtime_error(msg);
    }
  }
  shape_t calculate_stride(const shape_t&amp; sh) const {
    shape_t st(sh.size(), 1u);
    if (_stride.front() &lt; _stride.back()){
      for (size_t i=1; i&lt;st.size(); ++i) st[i] = st[i-1]*sh[i-1];
    } else {
      for (size_t i=st.size()-1; i--;) st[i] = st[i+1]*sh[i+1];
    }
    return st;
  }
  void reset_stride(){
    if (!this-&gt;is_contiguous())
      throw std::runtime_error(&quot;Re-calculating non-contiguous strides is not yet working&quot;);
    _stride = this-&gt;calculate_stride(_shape);
  }
  Array&lt;T&gt; _decouple() const {
    ind_t nnum = this-&gt;size_from_shape(_shape);
    T* new_data = new T[nnum]();
    if (nnum == _num) {
      std::copy(_data, _data+_num, new_data);
    } else {
      //subscript conversion necessary due to offset
      //                                   vvv(no offset)vvvv          vvv(offset)vvv
      for (auto x: SubIt(_shape)) new_data[sub2lin(x,_stride)] = _data[this-&gt;s2l_d(x)];
    }
    bool new_own = true; // always take ownership of C++ allocated memory
    auto new_ref = std::make_shared&lt;char&gt;(); // always use the default with C++ created arrays
    bool new_mut = true; // new allocated memory should be mutable
    return Array&lt;T&gt;(new_data, nnum, new_own, new_ref, _shape, _stride, new_mut);
  }
public:
  // sub-array access
  Array&lt;T&gt; view() const; // whole array non-owning view
  Array&lt;T&gt; view(ind_t i) const;
  Array&lt;T&gt; view(ind_t i, ind_t j) const;
  Array&lt;T&gt; view(const shape_t&amp;) const;
  // duplication of one or more sub-arrays:
  Array&lt;T&gt; extract(ind_t i) const;
  template&lt;class I&gt;             std::enable_if_t&lt;std::is_integral_v&lt;I&gt;, Array&lt;T&gt;&gt; extract(const Array&lt;I&gt;&amp; i) const;
  template&lt;class I&gt;             std::enable_if_t&lt;std::is_integral_v&lt;I&gt;, Array&lt;T&gt;&gt; extract(const std::vector&lt;I&gt;&amp; i) const;
  template&lt;class I, size_t Nel&gt; std::enable_if_t&lt;std::is_integral_v&lt;I&gt;, Array&lt;T&gt;&gt; extract(const std::array&lt;I,Nel&gt;&amp; i) const;
  template&lt;class I, size_t Nel&gt; std::enable_if_t&lt;std::is_integral_v&lt;I&gt;, Array&lt;T&gt;&gt; extract(const std::vector&lt;std::array&lt;I,Nel&gt;&gt;&amp; i) const;
  Array&lt;T&gt; extract(const Array&lt;bool&gt;&amp; i) const;
  Array&lt;T&gt; extract(const std::vector&lt;bool&gt;&amp; i) const;
  bool set(const ind_t i, const Array&lt;T&gt;&amp; in);
  template&lt;class R&gt;
  bool set(const ind_t i, const Array&lt;R&gt;&amp; in);
  bool set(const ind_t i, const std::vector&lt;T&gt;&amp; in);
  template&lt;size_t Nel&gt; bool set(const ind_t i, const std::array&lt;T,Nel&gt;&amp; in);
  T set(const shape_t&amp; sub, T in);
  Array&lt;T&gt;&amp; append(const ind_t, const Array&lt;T&gt;&amp;);
  std::string to_string() const;
  std::string to_string(const ind_t) const;

  Array&lt;T&gt;&amp; reshape(const shape_t&amp; ns);
  Array&lt;T&gt;&amp; resize(const shape_t&amp;, T init=T(0));
  template&lt;class I&gt; Array&lt;T&gt;&amp; resize(const I, T init=T(0));
  bool all(ind_t n=0) const;
  bool any(ind_t n=0) const;
  ind_t count(ind_t n=0) const;
  ind_t first(ind_t n=0) const;
  ind_t last(ind_t n=0) const;
  // bool all() const;
  // bool any() const;
  // ind_t count() const;
  // ind_t first() const;
  // ind_t last() const;
  bool all(T val, ind_t n=0) const;
  bool any(T val, ind_t n=0) const;
  ind_t count(T val, ind_t n=0) const;
  ind_t first(T val, ind_t n=0) const;
  ind_t last(T val, ind_t n=0) const;
  Array&lt;int&gt; round() const;
  Array&lt;int&gt; floor() const;
  Array&lt;int&gt; ceil() const;
  Array&lt;T&gt; sum(ind_t dim=0) const;
  Array&lt;T&gt; prod(ind_t dim=0) const;
  Array&lt;T&gt; min(ind_t dim=0) const;
  Array&lt;T&gt; max(ind_t dim=0) const;
  T sum() const;
  T prod() const;
  template&lt;class R, size_t Nel&gt;
  bool match(ind_t i, ind_t j, const std::array&lt;R,Nel&gt;&amp; rot, int order=1) const;
  bool match(ind_t i, ind_t j, ops op=ops::plus, T val=T{0}) const;
  bool all(cmp expr, T val) const;
  bool any(cmp expr, T val) const;
  ind_t first(cmp expr, T val) const;
  ind_t last(cmp expr, T val) const;
  ind_t count(cmp expr, T val) const;
  Array&lt;bool&gt; is(cmp expr, T val) const;
  std::vector&lt;ind_t&gt; find(cmp expr, T val) const;
  template&lt;class R&gt; Array&lt;bool&gt;       is(cmp expr, const Array&lt;R&gt;&amp; that) const;
  template&lt;class R&gt; std::vector&lt;bool&gt; is(cmp expr, const std::vector&lt;R&gt;&amp; val) const;
  template&lt;class R&gt; bool              is(const Array&lt;R&gt;&amp; that) const;
  std::vector&lt;bool&gt; is_unique() const;
  std::vector&lt;ind_t&gt; unique_idx() const;
  Array&lt;T&gt; unique() const;
  Array&lt;T&gt;  operator-() const;
  Array&lt;T&gt;&amp; operator +=(const T&amp;);
  Array&lt;T&gt;&amp; operator -=(const T&amp;);
  Array&lt;T&gt;&amp; operator *=(const T&amp;);
  Array&lt;T&gt;&amp; operator /=(const T&amp;);
  template&lt;class R&gt; Array&lt;T&gt;&amp; operator +=(const Array&lt;R&gt;&amp;);
  template&lt;class R&gt; Array&lt;T&gt;&amp; operator -=(const Array&lt;R&gt;&amp;);
  template&lt;class R&gt; Array&lt;T&gt;&amp; operator *=(const Array&lt;R&gt;&amp;);
  template&lt;class R&gt; Array&lt;T&gt;&amp; operator /=(const Array&lt;R&gt;&amp;);
  T dot(ind_t i, ind_t j) const;
  T norm(ind_t i) const;
  template&lt;typename I, typename=std::enable_if_t&lt;std::is_integral&lt;I&gt;::value&gt;&gt;
  void permute(std::vector&lt;I&gt;&amp; p);
  bool swap(ind_t a, ind_t b);
  bool swap(ind_t i, ind_t a, ind_t b);
  std::vector&lt;T&gt; to_std() const;
  T* ptr();
  T* ptr(const ind_t i0);
  template&lt;class ... Subs, class=std::enable_if_t&lt;brille::utils::are_same&lt;ind_t,Subs...&gt;::value, void&gt;&gt;
  T* ptr(const ind_t i0, Subs... subscripts);
  T* ptr(const shape_t&amp; partial_subscript);
  const T* ptr() const;
  const T* ptr(const ind_t i0) const;
  template&lt;class ... Subs, class=std::enable_if_t&lt;brille::utils::are_same&lt;ind_t,Subs...&gt;::value, void&gt;&gt;
  const T* ptr(const ind_t i0, Subs... subscripts) const;
  const T* ptr(const shape_t&amp; partial_subscript) const;
  T&amp; val(const ind_t i0);
  template&lt;class ... Subs, class=std::enable_if_t&lt;brille::utils::are_same&lt;ind_t,Subs...&gt;::value, void&gt;&gt;
  T&amp; val(const ind_t i0, Subs... subscripts);
  T&amp; val(const shape_t&amp; partial_subscript);
  template&lt;typename I&gt; T&amp; val(std::initializer_list&lt;I&gt; l);
  const T&amp; val(const ind_t i0) const;
  template&lt;class ... Subs, class=std::enable_if_t&lt;brille::utils::are_same&lt;ind_t,Subs...&gt;::value, void&gt;&gt;
  const T&amp; val(const ind_t i0, Subs... subscripts) const;
  const T&amp; val(const shape_t&amp; partial_subscript) const;
  template&lt;typename I&gt; const T&amp; val(std::initializer_list&lt;I&gt; l) const;

  Array&lt;T&gt; contiguous_copy() const;
  Array&lt;T&gt; contiguous_row_ordered_copy() const;
  Array&lt;T&gt; squeeze() const;
  Array&lt;T&gt; squeeze(const ind_t dim) const;
  Array&lt;T&gt; slice(const ind_t i0) const;
  bool shares_with(const Array&lt;T&gt;&amp; other) const {
    // compare the base pointer to see if two arrays share heap memory
    return other.data() == _data;
  }
  // ^^^^^^^^^^ IMPLEMENTED  ^^^^^^^^^^^vvvvvvvvv TO IMPLEMENT vvvvvvvvvvvvvvvvv

};

template&lt;class T&gt;
class ArrayIt {
public:
  Array&lt;T&gt; array;
  SubIt&lt;ind_t&gt; subit;
public:
  // constructing with array(a) does not copy the underlying data:
  explicit ArrayIt()
  : array(), subit()
  {}
  ArrayIt(const Array&lt;T&gt;&amp; a, const SubIt&lt;ind_t&gt;&amp; s)
  : array(a), subit(s)
  {}
  ArrayIt(const Array&lt;T&gt;&amp; a)
  : array(a), subit(a.shape()) // initialises to first element, e.g., {0,…,0}
  {}
  //
  ArrayIt&lt;T&gt; begin() const {
    return ArrayIt(array);
  }
  ArrayIt&lt;T&gt; end() const {
    return ArrayIt(array, subit.end());
  }
  ArrayIt&lt;T&gt;&amp; operator++() {
    ++subit;
    return *this;
  }
  const SubIt&lt;ind_t&gt;&amp; iterator() const {return subit;}
  bool operator==(const ArrayIt&lt;T&gt;&amp; other) const {
    // add checking to ensure array and other.array point to the same data?
    return subit == other.iterator();
  }
  bool operator!=(const ArrayIt&lt;T&gt;&amp; other) const {
    return subit != other.iterator();
  }
  const T&amp; operator*()  const {return array[*subit];}
  const T* operator-&gt;() const {return &amp;(array[*subit]);}
  T&amp; operator*()  {return array[*subit];}
  T* operator-&gt;() {return &amp;(array[*subit]);}
};


#include &quot;array.tpp&quot;
} // end namespace brille
#endif // ARRAY_HPP
</pre></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Gregory Tucker

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>